"use strict"; var wi = Object.create; var jt = Object.defineProperty; var Si = Object.getOwnPropertyDescriptor; var Ei = Object.getOwnPropertyNames; var qi = Object.getPrototypeOf, Li = Object.prototype.hasOwnProperty; var b = (t, e) => () => (t && (e = t(t = 0)), e); var Ii = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Bt = (t, e) => { for (var n in e) jt(t, n, { get: e[n], enumerable: !0 }) }, fn = (t, e, n, r) => { if (e && typeof e == "object" || typeof e == "function") for (let i of Ei(e)) !Li.call(t, i) && i !== n && jt(t, i, { get: () => e[i], enumerable: !(r = Si(e, i)) || r.enumerable }); return t }; var he = (t, e, n) => (n = t != null ? wi(qi(t)) : {}, fn(e || !t || !t.__esModule ? jt(n, "default", { value: t, enumerable: !0 }) : n, t)), Ti = t => fn(jt({}, "__esModule", { value: !0 }), t); function me(t) { if (t) throw t } var hn = b(() => { }); var Sn = Ii((ya, wn) => { "use strict"; var Mt = Object.prototype.hasOwnProperty, kn = Object.prototype.toString, mn = Object.defineProperty, dn = Object.getOwnPropertyDescriptor, gn = function (e) { return typeof Array.isArray == "function" ? Array.isArray(e) : kn.call(e) === "[object Array]" }, xn = function (e) { if (!e || kn.call(e) !== "[object Object]") return !1; var n = Mt.call(e, "constructor"), r = e.constructor && e.constructor.prototype && Mt.call(e.constructor.prototype, "isPrototypeOf"); if (e.constructor && !n && !r) return !1; var i; for (i in e); return typeof i > "u" || Mt.call(e, i) }, bn = function (e, n) { mn && n.name === "__proto__" ? mn(e, n.name, { enumerable: !0, configurable: !0, value: n.newValue, writable: !0 }) : e[n.name] = n.newValue }, yn = function (e, n) { if (n === "__proto__") if (Mt.call(e, n)) { if (dn) return dn(e, n).value } else return; return e[n] }; wn.exports = function t() { var e, n, r, i, o, a, u = arguments[0], f = 1, s = arguments.length, l = !1; for (typeof u == "boolean" && (l = u, u = arguments[1] || {}, f = 2), (u == null || typeof u != "object" && typeof u != "function") && (u = {}); f < s; ++f)if (e = arguments[f], e != null) for (n in e) r = yn(u, n), i = yn(e, n), u !== i && (l && i && (xn(i) || (o = gn(i))) ? (o ? (o = !1, a = r && gn(r) ? r : []) : a = r && xn(r) ? r : {}, bn(u, { name: n, newValue: t(l, a, i) })) : typeof i < "u" && bn(u, { name: n, newValue: i })); return u } }); function Nt(t) { if (typeof t != "object" || t === null) return !1; let e = Object.getPrototypeOf(t); return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t) } var En = b(() => { }); function qn() { let t = [], e = { run: n, use: r }; return e; function n(...i) { let o = -1, a = i.pop(); if (typeof a != "function") throw new TypeError("Expected function as last argument, not " + a); u(null, ...i); function u(f, ...s) { let l = t[++o], d = -1; if (f) { a(f); return } for (; ++d < i.length;)(s[d] === null || s[d] === void 0) && (s[d] = i[d]); i = s, l ? Ai(l, u)(...s) : a(null, ...s) } } function r(i) { if (typeof i != "function") throw new TypeError("Expected `middelware` to be a function, not " + i); return t.push(i), e } } function Ai(t, e) { let n; return r; function r(...a) { let u = t.length > a.length, f; u && a.push(i); try { f = t.apply(this, a) } catch (s) { let l = s; if (u && n) throw l; return i(l) } u || (f instanceof Promise ? f.then(o, i) : f instanceof Error ? i(f) : o(f)) } function i(a, ...u) { n || (n = !0, e(a, ...u)) } function o(a) { i(null, a) } } var Ln = b(() => { }); function ht(t) { return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? In(t.position) : "start" in t || "end" in t ? In(t) : "line" in t || "column" in t ? de(t) : "" } function de(t) { return Tn(t && t.line) + ":" + Tn(t && t.column) } function In(t) { return de(t && t.start) + "-" + de(t && t.end) } function Tn(t) { return t && typeof t == "number" ? t : 1 } var An = b(() => { }); var ge = b(() => { An() }); var Q, Cn = b(() => { ge(); Q = class extends Error { constructor(e, n, r) { super(), typeof n == "string" && (r = n, n = void 0); let i = "", o = {}, a = !1; if (n && ("line" in n && "column" in n ? o = { place: n } : "start" in n && "end" in n ? o = { place: n } : "type" in n ? o = { ancestors: [n], place: n.position } : o = { ...n }), typeof e == "string" ? i = e : !o.cause && e && (a = !0, i = e.message, o.cause = e), !o.ruleId && !o.source && typeof r == "string") { let f = r.indexOf(":"); f === -1 ? o.ruleId = r : (o.source = r.slice(0, f), o.ruleId = r.slice(f + 1)) } if (!o.place && o.ancestors && o.ancestors) { let f = o.ancestors[o.ancestors.length - 1]; f && (o.place = f.position) } let u = o.place && "start" in o.place ? o.place.start : o.place; this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = u ? u.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = u ? u.line : void 0, this.name = ht(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = a && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual, this.expected, this.note, this.url } }; Q.prototype.file = ""; Q.prototype.name = ""; Q.prototype.reason = ""; Q.prototype.message = ""; Q.prototype.stack = ""; Q.prototype.column = void 0; Q.prototype.line = void 0; Q.prototype.ancestors = void 0; Q.prototype.cause = void 0; Q.prototype.fatal = void 0; Q.prototype.place = void 0; Q.prototype.ruleId = void 0; Q.prototype.source = void 0 }); var zn = b(() => { Cn() }); var it, Dn = b(() => { it = he(require("node:path"), 1) }); var xe, Bn = b(() => { xe = he(require("node:process"), 1) }); function Gt(t) { return !!(t !== null && typeof t == "object" && "href" in t && t.href && "protocol" in t && t.protocol && t.auth === void 0) } var Nn = b(() => { }); var be, Pn = b(() => { be = require("node:url"); Nn() }); function ke(t, e) { if (t && t.includes(it.default.sep)) throw new Error("`" + e + "` cannot be a path: did not expect `" + it.default.sep + "`") } function we(t, e) { if (!t) throw new Error("`" + e + "` cannot be empty") } function Fn(t, e) { if (!t) throw new Error("Setting `" + e + "` requires `path` to be set too") } function Ci(t) { return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t) } var ye, Pt, On = b(() => { zn(); Dn(); Bn(); Pn(); ye = ["history", "path", "basename", "stem", "extname", "dirname"], Pt = class { constructor(e) { let n; e ? Gt(e) ? n = { path: e } : typeof e == "string" || Ci(e) ? n = { value: e } : n = e : n = {}, this.cwd = xe.default.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let r = -1; for (; ++r < ye.length;) { let o = ye[r]; o in n && n[o] !== void 0 && n[o] !== null && (this[o] = o === "history" ? [...n[o]] : n[o]) } let i; for (i in n) ye.includes(i) || (this[i] = n[i]) } get basename() { return typeof this.path == "string" ? it.default.basename(this.path) : void 0 } set basename(e) { we(e, "basename"), ke(e, "basename"), this.path = it.default.join(this.dirname || "", e) } get dirname() { return typeof this.path == "string" ? it.default.dirname(this.path) : void 0 } set dirname(e) { Fn(this.basename, "dirname"), this.path = it.default.join(e || "", this.basename) } get extname() { return typeof this.path == "string" ? it.default.extname(this.path) : void 0 } set extname(e) { if (ke(e, "extname"), Fn(this.dirname, "extname"), e) { if (e.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`"); if (e.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = it.default.join(this.dirname, this.stem + (e || "")) } get path() { return this.history[this.history.length - 1] } set path(e) { Gt(e) && (e = (0, be.fileURLToPath)(e)), we(e, "path"), this.path !== e && this.history.push(e) } get stem() { return typeof this.path == "string" ? it.default.basename(this.path, this.extname) : void 0 } set stem(e) { we(e, "stem"), ke(e, "stem"), this.path = it.default.join(this.dirname || "", e + (this.extname || "")) } fail(e, n, r) { let i = this.message(e, n, r); throw i.fatal = !0, i } info(e, n, r) { let i = this.message(e, n, r); return i.fatal = void 0, i } message(e, n, r) { let i = new Q(e, n, r); return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i } toString(e) { return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value) } } }); var Rn = b(() => { On() }); var vn, Vn = b(() => { vn = function (t) { let r = this.constructor.prototype, i = r[t], o = function () { return i.apply(o, arguments) }; Object.setPrototypeOf(o, r); let a = Object.getOwnPropertyNames(i); for (let u of a) { let f = Object.getOwnPropertyDescriptor(i, u); f && Object.defineProperty(o, u, f) } return o } }); function Se(t, e) { if (typeof e != "function") throw new TypeError("Cannot `" + t + "` without `parser`") } function Ee(t, e) { if (typeof e != "function") throw new TypeError("Cannot `" + t + "` without `compiler`") } function qe(t, e) { if (e) throw new Error("Cannot call `" + t + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function _n(t) { if (!Nt(t) || typeof t.type != "string") throw new TypeError("Expected node, got `" + t + "`") } function Hn(t, e, n) { if (!n) throw new Error("`" + t + "` finished async. Use `" + e + "` instead") } function Qt(t) { return Di(t) ? t : new Pt(t) } function Di(t) { return !!(t && typeof t == "object" && "message" in t && "messages" in t) } function Bi(t) { return typeof t == "string" || Ni(t) } function Ni(t) { return !!(t && typeof t == "object" && "byteLength" in t && "byteOffset" in t) } var Wt, zi, Le, Un, jn = b(() => { hn(); Wt = he(Sn(), 1); En(); Ln(); Rn(); Vn(); zi = {}.hasOwnProperty, Le = class t extends vn { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = qn() } copy() { let e = new t, n = -1; for (; ++n < this.attachers.length;) { let r = this.attachers[n]; e.use(...r) } return e.data((0, Wt.default)(!0, {}, this.namespace)), e } data(e, n) { return typeof e == "string" ? arguments.length === 2 ? (qe("data", this.frozen), this.namespace[e] = n, this) : zi.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (qe("data", this.frozen), this.namespace = e, this) : this.namespace } freeze() { if (this.frozen) return this; let e = this; for (; ++this.freezeIndex < this.attachers.length;) { let [n, ...r] = this.attachers[this.freezeIndex]; if (r[0] === !1) continue; r[0] === !0 && (r[0] = void 0); let i = n.call(e, ...r); typeof i == "function" && this.transformers.use(i) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(e) { this.freeze(); let n = Qt(e), r = this.parser || this.Parser; return Se("parse", r), r(String(n), n) } process(e, n) { let r = this; return this.freeze(), Se("process", this.parser || this.Parser), Ee("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i); function i(o, a) { let u = Qt(e), f = r.parse(u); r.run(f, u, function (l, d, m) { if (l || !d || !m) return s(l); let p = d, q = r.stringify(p, m); Bi(q) ? m.value = q : m.result = q, s(l, m) }); function s(l, d) { l || !d ? a(l) : o ? o(d) : n(void 0, d) } } } processSync(e) { let n = !1, r; return this.freeze(), Se("processSync", this.parser || this.Parser), Ee("processSync", this.compiler || this.Compiler), this.process(e, i), Hn("processSync", "process", n), r; function i(o, a) { n = !0, me(o), r = a } } run(e, n, r) { _n(e), this.freeze(); let i = this.transformers; return !r && typeof n == "function" && (r = n, n = void 0), r ? o(void 0, r) : new Promise(o); function o(a, u) { let f = Qt(n); i.run(e, f, s); function s(l, d, m) { let p = d || e; l ? u(l) : a ? a(p) : r(void 0, p, m) } } } runSync(e, n) { let r = !1, i; return this.run(e, n, o), Hn("runSync", "run", r), i; function o(a, u) { me(a), i = u, r = !0 } } stringify(e, n) { this.freeze(); let r = Qt(n), i = this.compiler || this.Compiler; return Ee("stringify", i), _n(e), i(e, r) } use(e, ...n) { let r = this.attachers, i = this.namespace; if (qe("use", this.frozen), e != null) if (typeof e == "function") f(e, n); else if (typeof e == "object") Array.isArray(e) ? u(e) : a(e); else throw new TypeError("Expected usable value, not `" + e + "`"); return this; function o(s) { if (typeof s == "function") f(s, []); else if (typeof s == "object") if (Array.isArray(s)) { let [l, ...d] = s; f(l, d) } else a(s); else throw new TypeError("Expected usable value, not `" + s + "`") } function a(s) { if (!("plugins" in s) && !("settings" in s)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); u(s.plugins), s.settings && (i.settings = (0, Wt.default)(!0, i.settings, s.settings)) } function u(s) { let l = -1; if (s != null) if (Array.isArray(s)) for (; ++l < s.length;) { let d = s[l]; o(d) } else throw new TypeError("Expected a list of plugins, not `" + s + "`") } function f(s, l) { let d = -1, m = -1; for (; ++d < r.length;)if (r[d][0] === s) { m = d; break } if (m === -1) r.push([s, ...l]); else if (l.length > 0) { let [p, ...q] = l, A = r[m][1]; Nt(A) && Nt(p) && (p = (0, Wt.default)(!0, A, p)), r[m] = [s, p, ...q] } } } }, Un = new Le().freeze() }); var Mn = {}; Bt(Mn, { unified: () => Un }); var Gn = b(() => { jn() }); function Ie(t, e) { let n = e || Pi, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0; return Wn(t, r, i) } function Wn(t, e, n) { if (Fi(t)) { if ("value" in t) return t.type === "html" && !n ? "" : t.value; if (e && "alt" in t && t.alt) return t.alt; if ("children" in t) return Qn(t.children, e, n) } return Array.isArray(t) ? Qn(t, e, n) : "" } function Qn(t, e, n) { let r = [], i = -1; for (; ++i < t.length;)r[i] = Wn(t[i], e, n); return r.join("") } function Fi(t) { return !!(t && typeof t == "object") } var Pi, Jn = b(() => { Pi = {} }); var Yn = b(() => { Jn() }); var Te, Zn = b(() => {
	Te = {
		AElig: "\xC6", AMP: "&", Aacute: "\xC1", Abreve: "\u0102", Acirc: "\xC2", Acy: "\u0410", Afr: "\u{1D504}", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\u{1D538}", ApplyFunction: "\u2061", Aring: "\xC5", Ascr: "\u{1D49C}", Assign: "\u2254", Atilde: "\xC3", Auml: "\xC4", Backslash: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", Bcy: "\u0411", Because: "\u2235", Bernoullis: "\u212C", Beta: "\u0392", Bfr: "\u{1D505}", Bopf: "\u{1D539}", Breve: "\u02D8", Bscr: "\u212C", Bumpeq: "\u224E", CHcy: "\u0427", COPY: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", Cayleys: "\u212D", Ccaron: "\u010C", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", CenterDot: "\xB7", Cfr: "\u212D", Chi: "\u03A7", CircleDot: "\u2299", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", Colon: "\u2237", Colone: "\u2A74", Congruent: "\u2261", Conint: "\u222F", ContourIntegral: "\u222E", Copf: "\u2102", Coproduct: "\u2210", CounterClockwiseContourIntegral: "\u2233", Cross: "\u2A2F", Cscr: "\u{1D49E}", Cup: "\u22D3", CupCap: "\u224D", DD: "\u2145", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", Delta: "\u0394", Dfr: "\u{1D507}", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", Diamond: "\u22C4", DifferentialD: "\u2146", Dopf: "\u{1D53B}", Dot: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", Downarrow: "\u21D3", Dscr: "\u{1D49F}", Dstrok: "\u0110", ENG: "\u014A", ETH: "\xD0", Eacute: "\xC9", Ecaron: "\u011A", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\u{1D508}", Egrave: "\xC8", Element: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\u{1D53C}", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", Equilibrium: "\u21CC", Escr: "\u2130", Esim: "\u2A73", Eta: "\u0397", Euml: "\xCB", Exists: "\u2203", ExponentialE: "\u2147", Fcy: "\u0424", Ffr: "\u{1D509}", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", Fopf: "\u{1D53D}", ForAll: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\u{1D50A}", Gg: "\u22D9", Gopf: "\u{1D53E}", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", Gt: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", HilbertSpace: "\u210B", Hopf: "\u210D", HorizontalLine: "\u2500", Hscr: "\u210B", Hstrok: "\u0126", HumpDownHump: "\u224E", HumpEqual: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xCD", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Igrave: "\xCC", Im: "\u2111", Imacr: "\u012A", ImaginaryI: "\u2148", Implies: "\u21D2", Int: "\u222C", Integral: "\u222B", Intersection: "\u22C2", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", Iogon: "\u012E", Iopf: "\u{1D540}", Iota: "\u0399", Iscr: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\u{1D50D}", Jopf: "\u{1D541}", Jscr: "\u{1D4A5}", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\u{1D50E}", Kopf: "\u{1D542}", Kscr: "\u{1D4A6}", LJcy: "\u0409", LT: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Larr: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", LeftRightArrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", Leftarrow: "\u21D0", Leftrightarrow: "\u21D4", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", Lfr: "\u{1D50F}", Ll: "\u22D8", Lleftarrow: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", LongLeftRightArrow: "\u27F7", LongRightArrow: "\u27F6", Longleftarrow: "\u27F8", Longleftrightarrow: "\u27FA", Longrightarrow: "\u27F9", Lopf: "\u{1D543}", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", Lscr: "\u2112", Lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", MinusPlus: "\u2213", Mopf: "\u{1D544}", Mscr: "\u2133", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, Nfr: "\u{1D511}", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", Nscr: "\u{1D4A9}", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacute: "\xD3", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\u{1D512}", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", Omicron: "\u039F", Oopf: "\u{1D546}", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", Or: "\u2A54", Oscr: "\u{1D4AA}", Oslash: "\xD8", Otilde: "\xD5", Otimes: "\u2A37", Ouml: "\xD6", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", Pcy: "\u041F", Pfr: "\u{1D513}", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", Poincareplane: "\u210C", Popf: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", Prime: "\u2033", Product: "\u220F", Proportion: "\u2237", Proportional: "\u221D", Pscr: "\u{1D4AB}", Psi: "\u03A8", QUOT: '"', Qfr: "\u{1D514}", Qopf: "\u211A", Qscr: "\u{1D4AC}", RBarr: "\u2910", REG: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", Rfr: "\u211C", Rho: "\u03A1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", Rightarrow: "\u21D2", Ropf: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", Rscr: "\u211B", Rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\u{1D516}", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", Sopf: "\u{1D54A}", Sqrt: "\u221A", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", Sscr: "\u{1D4AE}", Star: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", SuchThat: "\u220B", Sum: "\u2211", Sup: "\u22D1", Superset: "\u2283", SupersetEqual: "\u2287", Supset: "\u22D1", THORN: "\xDE", TRADE: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "	", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\u{1D517}", Therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", Topf: "\u{1D54B}", TripleDot: "\u20DB", Tscr: "\u{1D4AF}", Tstrok: "\u0166", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\u{1D518}", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", Uopf: "\u{1D54C}", UpArrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", UpEquilibrium: "\u296E", UpTee: "\u22A5", UpTeeArrow: "\u21A5", Uparrow: "\u21D1", Updownarrow: "\u21D5", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\u{1D4B0}", Utilde: "\u0168", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", Vopf: "\u{1D54D}", Vscr: "\u{1D4B1}", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", Wfr: "\u{1D51A}", Wopf: "\u{1D54E}", Wscr: "\u{1D4B2}", Xfr: "\u{1D51B}", Xi: "\u039E", Xopf: "\u{1D54F}", Xscr: "\u{1D4B3}", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\u{1D51C}", Yopf: "\u{1D550}", Yscr: "\u{1D4B4}", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", ZeroWidthSpace: "\u200B", Zeta: "\u0396", Zfr: "\u2128", Zopf: "\u2124", Zscr: "\u{1D4B5}", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acirc: "\xE2", acute: "\xB4", acy: "\u0430", aelig: "\xE6", af: "\u2061", afr: "\u{1D51E}", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", amp: "&", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", aogon: "\u0105", aopf: "\u{1D552}", ap: "\u2248", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", apid: "\u224B", apos: "'", approx: "\u2248", approxeq: "\u224A", aring: "\xE5", ascr: "\u{1D4B6}", ast: "*", asymp: "\u2248", asympeq: "\u224D", atilde: "\xE3", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", beta: "\u03B2", beth: "\u2136", between: "\u226C", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxh: "\u2500", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", bprime: "\u2035", breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", bumpeq: "\u224F", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", ccaps: "\u2A4D", ccaron: "\u010D", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cedil: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", cfr: "\u{1D520}", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledR: "\xAE", circledS: "\u24C8", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", conint: "\u222E", copf: "\u{1D554}", coprod: "\u2210", copy: "\xA9", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dArr: "\u21D3", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", darr: "\u2193", dash: "\u2010", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", dcaron: "\u010F", dcy: "\u0434", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", ddotseq: "\u2A77", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\u{1D521}", dharl: "\u21C3", dharr: "\u21C2", diam: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\u{1D555}", dot: "\u02D9", doteq: "\u2250", doteqdot: "\u2251", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", downarrow: "\u2193", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", dscr: "\u{1D4B9}", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eDDot: "\u2A77", eDot: "\u2251", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\u2256", ecirc: "\xEA", ecolon: "\u2255", ecy: "\u044D", edot: "\u0117", ee: "\u2147", efDot: "\u2252", efr: "\u{1D522}", eg: "\u2A9A", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", equals: "=", equest: "\u225F", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", erarr: "\u2971", escr: "\u212F", esdot: "\u2250", esim: "\u2242", eta: "\u03B7", eth: "\xF0", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", expectation: "\u2130", exponentiale: "\u2147", fallingdotseq: "\u2252", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\u{1D523}", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\u{1D557}", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", gE: "\u2267", gEl: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gammad: "\u03DD", gap: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", ge: "\u2265", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\u{1D524}", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", gjcy: "\u0453", gl: "\u2277", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", gopf: "\u{1D558}", grave: "`", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hArr: "\u21D4", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", hardcy: "\u044A", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", hbar: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", horbar: "\u2015", hscr: "\u{1D4BD}", hslash: "\u210F", hstrok: "\u0127", hybull: "\u2043", hyphen: "\u2010", iacute: "\xED", ic: "\u2063", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", image: "\u2111", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", int: "\u222B", intcal: "\u22BA", integers: "\u2124", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\u{1D55A}", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", isin: "\u2208", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", itilde: "\u0129", iukcy: "\u0456", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\u{1D527}", jmath: "\u0237", jopf: "\u{1D55B}", jscr: "\u{1D4BF}", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\u{1D528}", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\u{1D55C}", kscr: "\u{1D4C0}", lAarr: "\u21DA", lArr: "\u21D0", lAtail: "\u291B", lBarr: "\u290E", lE: "\u2266", lEg: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", lambda: "\u03BB", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", laquo: "\xAB", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lceil: "\u2308", lcub: "{", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leftarrow: "\u2190", leftarrowtail: "\u21A2", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", leftthreetimes: "\u22CB", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", lessgtr: "\u2276", lesssim: "\u2272", lfisht: "\u297C", lfloor: "\u230A", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", lstrok: "\u0142", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", measuredangle: "\u2221", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", mstpos: "\u223E", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nGtv: "\u226B\u0338", nLeftarrow: "\u21CD", nLeftrightarrow: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nLtv: "\u226A\u0338", nRightarrow: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nabla: "\u2207", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", neArr: "\u21D7", nearhk: "\u2924", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", nexist: "\u2204", nexists: "\u2204", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", ngsim: "\u2275", ngt: "\u226F", ngtr: "\u226F", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", njcy: "\u045A", nlArr: "\u21CD", nlE: "\u2266\u0338", nlarr: "\u219A", nldr: "\u2025", nle: "\u2270", nleftarrow: "\u219A", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nlsim: "\u2274", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nmid: "\u2224", nopf: "\u{1D55F}", not: "\xAC", notin: "\u2209", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", oS: "\u24C8", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", ocirc: "\xF4", ocy: "\u043E", odash: "\u229D", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\u{1D52C}", ogon: "\u02DB", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", oopf: "\u{1D560}", opar: "\u29B7", operp: "\u29B9", oplus: "\u2295", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oscr: "\u2134", oslash: "\xF8", osol: "\u2298", otilde: "\xF5", otimes: "\u2297", otimesas: "\u2A36", ouml: "\xF6", ovbar: "\u233D", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", pfr: "\u{1D52D}", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", pointint: "\u2A15", popf: "\u{1D561}", pound: "\xA3", pr: "\u227A", prE: "\u2AB3", prap: "\u2AB7", prcue: "\u227C", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", prime: "\u2032", primes: "\u2119", prnE: "\u2AB5", prnap: "\u2AB9", prnsim: "\u22E8", prod: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", pscr: "\u{1D4C5}", psi: "\u03C8", puncsp: "\u2008", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", qprime: "\u2057", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', rAarr: "\u21DB", rArr: "\u21D2", rAtail: "\u291C", rBarr: "\u290F", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rceil: "\u2309", rcub: "}", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", reg: "\xAE", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", rightarrow: "\u2192", rightarrowtail: "\u21A3", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", rightthreetimes: "\u22CC", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", rsaquo: "\u203A", rscr: "\u{1D4C7}", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", sbquo: "\u201A", sc: "\u227B", scE: "\u2AB4", scap: "\u2AB8", scaron: "\u0161", sccue: "\u227D", sce: "\u2AB0", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", scnap: "\u2ABA", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", seArr: "\u21D8", searhk: "\u2925", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shortmid: "\u2223", shortparallel: "\u2225", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", square: "\u25A1", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", subE: "\u2AC5", subdot: "\u2ABD", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", supE: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supe: "\u2287", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swarhk: "\u2926", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tbrk: "\u23B4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", thorn: "\xFE", tilde: "\u02DC", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\u{1D4C9}", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", uArr: "\u21D1", uHar: "\u2963", uacute: "\xFA", uarr: "\u2191", ubrcy: "\u045E", ubreve: "\u016D", ucirc: "\xFB", ucy: "\u0443", udarr: "\u21C5", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", ufr: "\u{1D532}", ugrave: "\xF9", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", uml: "\xA8", uogon: "\u0173", uopf: "\u{1D566}", uparrow: "\u2191", updownarrow: "\u2195", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", upsi: "\u03C5", upsih: "\u03D2", upsilon: "\u03C5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\u{1D4CA}", utdot: "\u22F0", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", uuml: "\xFC", uwangle: "\u29A7", vArr: "\u21D5", vBar: "\u2AE8", vBarv: "\u2AE9", vDash: "\u22A8", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vcy: "\u0432", vdash: "\u22A2", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", vert: "|", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", wfr: "\u{1D534}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", yen: "\xA5", yfr: "\u{1D536}", yicy: "\u0457", yopf: "\u{1D56A}", yscr: "\u{1D4CE}", yucy: "\u044E", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeetrf: "\u2128", zeta: "\u03B6", zfr: "\u{1D537}", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C"
	}
}); function It(t) { return Oi.call(Te, t) ? Te[t] : !1 } var Oi, Jt = b(() => { Zn(); Oi = {}.hasOwnProperty }); function Y(t, e, n, r) { let i = t.length, o = 0, a; if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, n = n > 0 ? n : 0, r.length < 1e4) a = Array.from(r), a.unshift(e, n), t.splice(...a); else for (n && t.splice(e, n); o < r.length;)a = r.slice(o, o + 1e4), a.unshift(e, 0), t.splice(...a), o += 1e4, e += 1e4 } function K(t, e) { return t.length > 0 ? (Y(t, t.length, 0, e), t) : e } var mt = b(() => { }); function Xn(t) { let e = {}, n = -1; for (; ++n < t.length;)Ri(e, t[n]); return e } function Ri(t, e) { let n; for (n in e) { let i = (Kn.call(t, n) ? t[n] : void 0) || (t[n] = {}), o = e[n], a; if (o) for (a in o) { Kn.call(i, a) || (i[a] = []); let u = o[a]; vi(i[a], Array.isArray(u) ? u : u ? [u] : []) } } } function vi(t, e) { let n = -1, r = []; for (; ++n < e.length;)(e[n].add === "after" ? t : r).push(e[n]); Y(t, 0, 0, r) } var Kn, $n = b(() => { mt(); Kn = {}.hasOwnProperty }); function Yt(t, e) { let n = Number.parseInt(t, e); return n < 9 || n === 11 || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || (n & 65535) === 65535 || (n & 65535) === 65534 || n > 1114111 ? "\uFFFD" : String.fromCodePoint(n) } var Ae = b(() => { }); function ft(t) { return t.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } var Zt = b(() => { }); function Ft(t) { return t !== null && (t < 32 || t === 127) } function w(t) { return t !== null && t < -2 } function j(t) { return t !== null && (t < 0 || t === 32) } function L(t) { return t === -2 || t === -1 || t === 32 } function nr(t) { return Ce(t) || Vi(t) } function dt(t) { return e; function e(n) { return n !== null && n > -1 && t.test(String.fromCharCode(n)) } } var Vi, et, X, tr, Ot, er, Ce, rr, F = b(() => { Vi = dt(/\p{P}/u), et = dt(/[A-Za-z]/), X = dt(/[\dA-Za-z]/), tr = dt(/[#-'*+\--9=?A-Z^-~]/); Ot = dt(/\d/), er = dt(/[\dA-Fa-f]/), Ce = dt(/[!-/:-@[-`{-~]/); rr = dt(/\s/) }); function T(t, e, n, r) { let i = r ? r - 1 : Number.POSITIVE_INFINITY, o = 0; return a; function a(f) { return L(f) ? (t.enter(n), u(f)) : e(f) } function u(f) { return L(f) && o++ < i ? (t.consume(f), u) : (t.exit(n), e(f)) } } var W = b(() => { F() }); function _i(t) { let e = t.attempt(this.parser.constructs.contentInitial, r, i), n; return e; function r(u) { if (u === null) { t.consume(u); return } return t.enter("lineEnding"), t.consume(u), t.exit("lineEnding"), T(t, e, "linePrefix") } function i(u) { return t.enter("paragraph"), o(u) } function o(u) { let f = t.enter("chunkText", { contentType: "text", previous: n }); return n && (n.next = f), n = f, a(u) } function a(u) { if (u === null) { t.exit("chunkText"), t.exit("paragraph"), t.consume(u); return } return w(u) ? (t.consume(u), t.exit("chunkText"), o) : (t.consume(u), a) } } var ir, or = b(() => { W(); F(); ir = { tokenize: _i } }); function Hi(t) { let e = this, n = [], r = 0, i, o, a; return u; function u(S) { if (r < n.length) { let V = n[r]; return e.containerState = V[1], t.attempt(V[0].continuation, f, s)(S) } return s(S) } function f(S) { if (r++, e.containerState._closeFlow) { e.containerState._closeFlow = void 0, i && v(); let V = e.events.length, H = V, x; for (; H--;)if (e.events[H][0] === "exit" && e.events[H][1].type === "chunkFlow") { x = e.events[H][1].end; break } k(r); let R = V; for (; R < e.events.length;)e.events[R][1].end = Object.assign({}, x), R++; return Y(e.events, H + 1, 0, e.events.slice(V)), e.events.length = R, s(S) } return u(S) } function s(S) { if (r === n.length) { if (!i) return m(S); if (i.currentConstruct && i.currentConstruct.concrete) return q(S); e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack) } return e.containerState = {}, t.check(ar, l, d)(S) } function l(S) { return i && v(), k(r), m(S) } function d(S) { return e.parser.lazy[e.now().line] = r !== n.length, a = e.now().offset, q(S) } function m(S) { return e.containerState = {}, t.attempt(ar, p, q)(S) } function p(S) { return r++, n.push([e.currentConstruct, e.containerState]), m(S) } function q(S) { if (S === null) { i && v(), k(0), t.consume(S); return } return i = i || e.parser.flow(e.now()), t.enter("chunkFlow", { contentType: "flow", previous: o, _tokenizer: i }), A(S) } function A(S) { if (S === null) { N(t.exit("chunkFlow"), !0), k(0), t.consume(S); return } return w(S) ? (t.consume(S), N(t.exit("chunkFlow")), r = 0, e.interrupt = void 0, u) : (t.consume(S), A) } function N(S, V) { let H = e.sliceStream(S); if (V && H.push(null), S.previous = o, o && (o.next = S), o = S, i.defineSkip(S.start), i.write(H), e.parser.lazy[S.start.line]) { let x = i.events.length; for (; x--;)if (i.events[x][1].start.offset < a && (!i.events[x][1].end || i.events[x][1].end.offset > a)) return; let R = e.events.length, M = R, B, _; for (; M--;)if (e.events[M][0] === "exit" && e.events[M][1].type === "chunkFlow") { if (B) { _ = e.events[M][1].end; break } B = !0 } for (k(r), x = R; x < e.events.length;)e.events[x][1].end = Object.assign({}, _), x++; Y(e.events, M + 1, 0, e.events.slice(R)), e.events.length = x } } function k(S) { let V = n.length; for (; V-- > S;) { let H = n[V]; e.containerState = H[1], H[0].exit.call(e, t) } n.length = S } function v() { i.write([null]), o = void 0, i = void 0, e.containerState._closeFlow = void 0 } } function Ui(t, e, n) { return T(t, t.attempt(this.parser.constructs.document, e, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } var ur, ar, sr = b(() => { W(); F(); mt(); ur = { tokenize: Hi }, ar = { tokenize: Ui } }); function ze(t) { if (t === null || j(t) || rr(t)) return 1; if (nr(t)) return 2 } var lr = b(() => { F() }); function Tt(t, e, n) { let r = [], i = -1; for (; ++i < t.length;) { let o = t[i].resolveAll; o && !r.includes(o) && (e = o(e, n), r.push(o)) } return e } var Kt = b(() => { }); function ji(t, e) { let n = -1, r, i, o, a, u, f, s, l; for (; ++n < t.length;)if (t[n][0] === "enter" && t[n][1].type === "attentionSequence" && t[n][1]._close) { for (r = n; r--;)if (t[r][0] === "exit" && t[r][1].type === "attentionSequence" && t[r][1]._open && e.sliceSerialize(t[r][1]).charCodeAt(0) === e.sliceSerialize(t[n][1]).charCodeAt(0)) { if ((t[r][1]._close || t[n][1]._open) && (t[n][1].end.offset - t[n][1].start.offset) % 3 && !((t[r][1].end.offset - t[r][1].start.offset + t[n][1].end.offset - t[n][1].start.offset) % 3)) continue; f = t[r][1].end.offset - t[r][1].start.offset > 1 && t[n][1].end.offset - t[n][1].start.offset > 1 ? 2 : 1; let d = Object.assign({}, t[r][1].end), m = Object.assign({}, t[n][1].start); cr(d, -f), cr(m, f), a = { type: f > 1 ? "strongSequence" : "emphasisSequence", start: d, end: Object.assign({}, t[r][1].end) }, u = { type: f > 1 ? "strongSequence" : "emphasisSequence", start: Object.assign({}, t[n][1].start), end: m }, o = { type: f > 1 ? "strongText" : "emphasisText", start: Object.assign({}, t[r][1].end), end: Object.assign({}, t[n][1].start) }, i = { type: f > 1 ? "strong" : "emphasis", start: Object.assign({}, a.start), end: Object.assign({}, u.end) }, t[r][1].end = Object.assign({}, a.start), t[n][1].start = Object.assign({}, u.end), s = [], t[r][1].end.offset - t[r][1].start.offset && (s = K(s, [["enter", t[r][1], e], ["exit", t[r][1], e]])), s = K(s, [["enter", i, e], ["enter", a, e], ["exit", a, e], ["enter", o, e]]), s = K(s, Tt(e.parser.constructs.insideSpan.null, t.slice(r + 1, n), e)), s = K(s, [["exit", o, e], ["enter", u, e], ["exit", u, e], ["exit", i, e]]), t[n][1].end.offset - t[n][1].start.offset ? (l = 2, s = K(s, [["enter", t[n][1], e], ["exit", t[n][1], e]])) : l = 0, Y(t, r - 1, n - r + 3, s), n = r + s.length - l - 2; break } } for (n = -1; ++n < t.length;)t[n][1].type === "attentionSequence" && (t[n][1].type = "data"); return t } function Mi(t, e) { let n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = ze(r), o; return a; function a(f) { return o = f, t.enter("attentionSequence"), u(f) } function u(f) { if (f === o) return t.consume(f), u; let s = t.exit("attentionSequence"), l = ze(f), d = !l || l === 2 && i || n.includes(f), m = !i || i === 2 && l || n.includes(r); return s._open = !!(o === 42 ? d : d && (i || !m)), s._close = !!(o === 42 ? m : m && (l || !d)), e(f) } } function cr(t, e) { t.column += e, t.offset += e, t._bufferIndex += e } var Rt, pr = b(() => { mt(); lr(); Kt(); Rt = { name: "attention", tokenize: Mi, resolveAll: ji } }); function Gi(t, e, n) { let r = 0; return i; function i(p) { return t.enter("autolink"), t.enter("autolinkMarker"), t.consume(p), t.exit("autolinkMarker"), t.enter("autolinkProtocol"), o } function o(p) { return et(p) ? (t.consume(p), a) : s(p) } function a(p) { return p === 43 || p === 45 || p === 46 || X(p) ? (r = 1, u(p)) : s(p) } function u(p) { return p === 58 ? (t.consume(p), r = 0, f) : (p === 43 || p === 45 || p === 46 || X(p)) && r++ < 32 ? (t.consume(p), u) : (r = 0, s(p)) } function f(p) { return p === 62 ? (t.exit("autolinkProtocol"), t.enter("autolinkMarker"), t.consume(p), t.exit("autolinkMarker"), t.exit("autolink"), e) : p === null || p === 32 || p === 60 || Ft(p) ? n(p) : (t.consume(p), f) } function s(p) { return p === 64 ? (t.consume(p), l) : tr(p) ? (t.consume(p), s) : n(p) } function l(p) { return X(p) ? d(p) : n(p) } function d(p) { return p === 46 ? (t.consume(p), r = 0, l) : p === 62 ? (t.exit("autolinkProtocol").type = "autolinkEmail", t.enter("autolinkMarker"), t.consume(p), t.exit("autolinkMarker"), t.exit("autolink"), e) : m(p) } function m(p) { if ((p === 45 || X(p)) && r++ < 63) { let q = p === 45 ? m : d; return t.consume(p), q } return n(p) } } var De, fr = b(() => { F(); De = { name: "autolink", tokenize: Gi } }); function Qi(t, e, n) { return r; function r(o) { return L(o) ? T(t, i, "linePrefix")(o) : i(o) } function i(o) { return o === null || w(o) ? e(o) : n(o) } } var gt, Xt = b(() => { W(); F(); gt = { tokenize: Qi, partial: !0 } }); function Wi(t, e, n) { let r = this; return i; function i(a) { if (a === 62) { let u = r.containerState; return u.open || (t.enter("blockQuote", { _container: !0 }), u.open = !0), t.enter("blockQuotePrefix"), t.enter("blockQuoteMarker"), t.consume(a), t.exit("blockQuoteMarker"), o } return n(a) } function o(a) { return L(a) ? (t.enter("blockQuotePrefixWhitespace"), t.consume(a), t.exit("blockQuotePrefixWhitespace"), t.exit("blockQuotePrefix"), e) : (t.exit("blockQuotePrefix"), e(a)) } } function Ji(t, e, n) { let r = this; return i; function i(a) { return L(a) ? T(t, o, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : o(a) } function o(a) { return t.attempt($t, e, n)(a) } } function Yi(t) { t.exit("blockQuote") } var $t, hr = b(() => { W(); F(); $t = { name: "blockQuote", tokenize: Wi, continuation: { tokenize: Ji }, exit: Yi } }); function Zi(t, e, n) { return r; function r(o) { return t.enter("characterEscape"), t.enter("escapeMarker"), t.consume(o), t.exit("escapeMarker"), i } function i(o) { return Ce(o) ? (t.enter("characterEscapeValue"), t.consume(o), t.exit("characterEscapeValue"), t.exit("characterEscape"), e) : n(o) } } var te, mr = b(() => { F(); te = { name: "characterEscape", tokenize: Zi } }); function Ki(t, e, n) { let r = this, i = 0, o, a; return u; function u(d) { return t.enter("characterReference"), t.enter("characterReferenceMarker"), t.consume(d), t.exit("characterReferenceMarker"), f } function f(d) { return d === 35 ? (t.enter("characterReferenceMarkerNumeric"), t.consume(d), t.exit("characterReferenceMarkerNumeric"), s) : (t.enter("characterReferenceValue"), o = 31, a = X, l(d)) } function s(d) { return d === 88 || d === 120 ? (t.enter("characterReferenceMarkerHexadecimal"), t.consume(d), t.exit("characterReferenceMarkerHexadecimal"), t.enter("characterReferenceValue"), o = 6, a = er, l) : (t.enter("characterReferenceValue"), o = 7, a = Ot, l(d)) } function l(d) { if (d === 59 && i) { let m = t.exit("characterReferenceValue"); return a === X && !It(r.sliceSerialize(m)) ? n(d) : (t.enter("characterReferenceMarker"), t.consume(d), t.exit("characterReferenceMarker"), t.exit("characterReference"), e) } return a(d) && i++ < o ? (t.consume(d), l) : n(d) } } var ee, dr = b(() => { Jt(); F(); ee = { name: "characterReference", tokenize: Ki } }); function Xi(t, e, n) { let r = this, i = { tokenize: H, partial: !0 }, o = 0, a = 0, u; return f; function f(x) { return s(x) } function s(x) { let R = r.events[r.events.length - 1]; return o = R && R[1].type === "linePrefix" ? R[2].sliceSerialize(R[1], !0).length : 0, u = x, t.enter("codeFenced"), t.enter("codeFencedFence"), t.enter("codeFencedFenceSequence"), l(x) } function l(x) { return x === u ? (a++, t.consume(x), l) : a < 3 ? n(x) : (t.exit("codeFencedFenceSequence"), L(x) ? T(t, d, "whitespace")(x) : d(x)) } function d(x) { return x === null || w(x) ? (t.exit("codeFencedFence"), r.interrupt ? e(x) : t.check(gr, A, V)(x)) : (t.enter("codeFencedFenceInfo"), t.enter("chunkString", { contentType: "string" }), m(x)) } function m(x) { return x === null || w(x) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), d(x)) : L(x) ? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), T(t, p, "whitespace")(x)) : x === 96 && x === u ? n(x) : (t.consume(x), m) } function p(x) { return x === null || w(x) ? d(x) : (t.enter("codeFencedFenceMeta"), t.enter("chunkString", { contentType: "string" }), q(x)) } function q(x) { return x === null || w(x) ? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), d(x)) : x === 96 && x === u ? n(x) : (t.consume(x), q) } function A(x) { return t.attempt(i, V, N)(x) } function N(x) { return t.enter("lineEnding"), t.consume(x), t.exit("lineEnding"), k } function k(x) { return o > 0 && L(x) ? T(t, v, "linePrefix", o + 1)(x) : v(x) } function v(x) { return x === null || w(x) ? t.check(gr, A, V)(x) : (t.enter("codeFlowValue"), S(x)) } function S(x) { return x === null || w(x) ? (t.exit("codeFlowValue"), v(x)) : (t.consume(x), S) } function V(x) { return t.exit("codeFenced"), e(x) } function H(x, R, M) { let B = 0; return _; function _(C) { return x.enter("lineEnding"), x.consume(C), x.exit("lineEnding"), nt } function nt(C) { return x.enter("codeFencedFence"), L(C) ? T(x, O, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(C) : O(C) } function O(C) { return C === u ? (x.enter("codeFencedFenceSequence"), E(C)) : M(C) } function E(C) { return C === u ? (B++, x.consume(C), E) : B >= a ? (x.exit("codeFencedFenceSequence"), L(C) ? T(x, z, "whitespace")(C) : z(C)) : M(C) } function z(C) { return C === null || w(C) ? (x.exit("codeFencedFence"), R(C)) : M(C) } } } function $i(t, e, n) { let r = this; return i; function i(a) { return a === null ? n(a) : (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), o) } function o(a) { return r.parser.lazy[r.now().line] ? n(a) : e(a) } } var gr, ne, xr = b(() => { W(); F(); gr = { tokenize: $i, partial: !0 }, ne = { name: "codeFenced", tokenize: Xi, concrete: !0 } }); function eo(t, e, n) { let r = this; return i; function i(s) { return t.enter("codeIndented"), T(t, o, "linePrefix", 5)(s) } function o(s) { let l = r.events[r.events.length - 1]; return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? a(s) : n(s) } function a(s) { return s === null ? f(s) : w(s) ? t.attempt(to, a, f)(s) : (t.enter("codeFlowValue"), u(s)) } function u(s) { return s === null || w(s) ? (t.exit("codeFlowValue"), a(s)) : (t.consume(s), u) } function f(s) { return t.exit("codeIndented"), e(s) } } function no(t, e, n) { let r = this; return i; function i(a) { return r.parser.lazy[r.now().line] ? n(a) : w(a) ? (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), i) : T(t, o, "linePrefix", 5)(a) } function o(a) { let u = r.events[r.events.length - 1]; return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? e(a) : w(a) ? i(a) : n(a) } } var vt, to, br = b(() => { W(); F(); vt = { name: "codeIndented", tokenize: eo }, to = { tokenize: no, partial: !0 } }); function ro(t) { let e = t.length - 4, n = 3, r, i; if ((t[n][1].type === "lineEnding" || t[n][1].type === "space") && (t[e][1].type === "lineEnding" || t[e][1].type === "space")) { for (r = n; ++r < e;)if (t[r][1].type === "codeTextData") { t[n][1].type = "codeTextPadding", t[e][1].type = "codeTextPadding", n += 2, e -= 2; break } } for (r = n - 1, e++; ++r <= e;)i === void 0 ? r !== e && t[r][1].type !== "lineEnding" && (i = r) : (r === e || t[r][1].type === "lineEnding") && (t[i][1].type = "codeTextData", r !== i + 2 && (t[i][1].end = t[r - 1][1].end, t.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0); return t } function io(t) { return t !== 96 || this.events[this.events.length - 1][1].type === "characterEscape" } function oo(t, e, n) { let r = this, i = 0, o, a; return u; function u(m) { return t.enter("codeText"), t.enter("codeTextSequence"), f(m) } function f(m) { return m === 96 ? (t.consume(m), i++, f) : (t.exit("codeTextSequence"), s(m)) } function s(m) { return m === null ? n(m) : m === 32 ? (t.enter("space"), t.consume(m), t.exit("space"), s) : m === 96 ? (a = t.enter("codeTextSequence"), o = 0, d(m)) : w(m) ? (t.enter("lineEnding"), t.consume(m), t.exit("lineEnding"), s) : (t.enter("codeTextData"), l(m)) } function l(m) { return m === null || m === 32 || m === 96 || w(m) ? (t.exit("codeTextData"), s(m)) : (t.consume(m), l) } function d(m) { return m === 96 ? (t.consume(m), o++, d) : o === i ? (t.exit("codeTextSequence"), t.exit("codeText"), e(m)) : (a.type = "codeTextData", l(m)) } } var Be, yr = b(() => { F(); Be = { name: "codeText", tokenize: oo, resolve: ro, previous: io } }); function re(t) { let e = {}, n = -1, r, i, o, a, u, f, s; for (; ++n < t.length;) { for (; n in e;)n = e[n]; if (r = t[n], n && r[1].type === "chunkFlow" && t[n - 1][1].type === "listItemPrefix" && (f = r[1]._tokenizer.events, o = 0, o < f.length && f[o][1].type === "lineEndingBlank" && (o += 2), o < f.length && f[o][1].type === "content")) for (; ++o < f.length && f[o][1].type !== "content";)f[o][1].type === "chunkText" && (f[o][1]._isInFirstContentOfListItem = !0, o++); if (r[0] === "enter") r[1].contentType && (Object.assign(e, ao(t, n)), n = e[n], s = !0); else if (r[1]._container) { for (o = n, i = void 0; o-- && (a = t[o], a[1].type === "lineEnding" || a[1].type === "lineEndingBlank");)a[0] === "enter" && (i && (t[i][1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = o); i && (r[1].end = Object.assign({}, t[i][1].start), u = t.slice(i, n), u.unshift(r), Y(t, i, n - i + 1, u)) } } return !s } function ao(t, e) { let n = t[e][1], r = t[e][2], i = e - 1, o = [], a = n._tokenizer || r.parser[n.contentType](n.start), u = a.events, f = [], s = {}, l, d, m = -1, p = n, q = 0, A = 0, N = [A]; for (; p;) { for (; t[++i][1] !== p;); o.push(i), p._tokenizer || (l = r.sliceStream(p), p.next || l.push(null), d && a.defineSkip(p.start), p._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(l), p._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), d = p, p = p.next } for (p = n; ++m < u.length;)u[m][0] === "exit" && u[m - 1][0] === "enter" && u[m][1].type === u[m - 1][1].type && u[m][1].start.line !== u[m][1].end.line && (A = m + 1, N.push(A), p._tokenizer = void 0, p.previous = void 0, p = p.next); for (a.events = [], p ? (p._tokenizer = void 0, p.previous = void 0) : N.pop(), m = N.length; m--;) { let k = u.slice(N[m], N[m + 1]), v = o.pop(); f.unshift([v, v + k.length - 1]), Y(t, v, 2, k) } for (m = -1; ++m < f.length;)s[q + f[m][0]] = q + f[m][1], q += f[m][1] - f[m][0] - 1; return s } var Ne = b(() => { mt() }); function so(t) { return re(t), t } function lo(t, e) { let n; return r; function r(u) { return t.enter("content"), n = t.enter("chunkContent", { contentType: "content" }), i(u) } function i(u) { return u === null ? o(u) : w(u) ? t.check(uo, a, o)(u) : (t.consume(u), i) } function o(u) { return t.exit("chunkContent"), t.exit("content"), e(u) } function a(u) { return t.consume(u), t.exit("chunkContent"), n.next = t.enter("chunkContent", { contentType: "content", previous: n }), n = n.next, i } } function co(t, e, n) { let r = this; return i; function i(a) { return t.exit("chunkContent"), t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), T(t, o, "linePrefix") } function o(a) { if (a === null || w(a)) return n(a); let u = r.events[r.events.length - 1]; return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? e(a) : t.interrupt(r.parser.constructs.flow, n, e)(a) } } var Pe, uo, kr = b(() => { W(); F(); Ne(); Pe = { tokenize: lo, resolve: so }, uo = { tokenize: co, partial: !0 } }); function ie(t, e, n, r, i, o, a, u, f) { let s = f || Number.POSITIVE_INFINITY, l = 0; return d; function d(k) { return k === 60 ? (t.enter(r), t.enter(i), t.enter(o), t.consume(k), t.exit(o), m) : k === null || k === 32 || k === 41 || Ft(k) ? n(k) : (t.enter(r), t.enter(a), t.enter(u), t.enter("chunkString", { contentType: "string" }), A(k)) } function m(k) { return k === 62 ? (t.enter(o), t.consume(k), t.exit(o), t.exit(i), t.exit(r), e) : (t.enter(u), t.enter("chunkString", { contentType: "string" }), p(k)) } function p(k) { return k === 62 ? (t.exit("chunkString"), t.exit(u), m(k)) : k === null || k === 60 || w(k) ? n(k) : (t.consume(k), k === 92 ? q : p) } function q(k) { return k === 60 || k === 62 || k === 92 ? (t.consume(k), p) : p(k) } function A(k) { return !l && (k === null || k === 41 || j(k)) ? (t.exit("chunkString"), t.exit(u), t.exit(a), t.exit(r), e(k)) : l < s && k === 40 ? (t.consume(k), l++, A) : k === 41 ? (t.consume(k), l--, A) : k === null || k === 32 || k === 40 || Ft(k) ? n(k) : (t.consume(k), k === 92 ? N : A) } function N(k) { return k === 40 || k === 41 || k === 92 ? (t.consume(k), A) : A(k) } } var Fe = b(() => { F() }); function oe(t, e, n, r, i, o) { let a = this, u = 0, f; return s; function s(p) { return t.enter(r), t.enter(i), t.consume(p), t.exit(i), t.enter(o), l } function l(p) { return u > 999 || p === null || p === 91 || p === 93 && !f || p === 94 && !u && "_hiddenFootnoteSupport" in a.parser.constructs ? n(p) : p === 93 ? (t.exit(o), t.enter(i), t.consume(p), t.exit(i), t.exit(r), e) : w(p) ? (t.enter("lineEnding"), t.consume(p), t.exit("lineEnding"), l) : (t.enter("chunkString", { contentType: "string" }), d(p)) } function d(p) { return p === null || p === 91 || p === 93 || w(p) || u++ > 999 ? (t.exit("chunkString"), l(p)) : (t.consume(p), f || (f = !L(p)), p === 92 ? m : d) } function m(p) { return p === 91 || p === 92 || p === 93 ? (t.consume(p), u++, d) : d(p) } } var Oe = b(() => { F() }); function ae(t, e, n, r, i, o) { let a; return u; function u(m) { return m === 34 || m === 39 || m === 40 ? (t.enter(r), t.enter(i), t.consume(m), t.exit(i), a = m === 40 ? 41 : m, f) : n(m) } function f(m) { return m === a ? (t.enter(i), t.consume(m), t.exit(i), t.exit(r), e) : (t.enter(o), s(m)) } function s(m) { return m === a ? (t.exit(o), f(a)) : m === null ? n(m) : w(m) ? (t.enter("lineEnding"), t.consume(m), t.exit("lineEnding"), T(t, s, "linePrefix")) : (t.enter("chunkString", { contentType: "string" }), l(m)) } function l(m) { return m === a || m === null || w(m) ? (t.exit("chunkString"), s(m)) : (t.consume(m), m === 92 ? d : l) } function d(m) { return m === a || m === 92 ? (t.consume(m), l) : l(m) } } var Re = b(() => { W(); F() }); function kt(t, e) { let n; return r; function r(i) { return w(i) ? (t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), n = !0, r) : L(i) ? T(t, r, n ? "linePrefix" : "lineSuffix")(i) : e(i) } } var ve = b(() => { W(); F() }); function fo(t, e, n) { let r = this, i; return o; function o(p) { return t.enter("definition"), a(p) } function a(p) { return oe.call(r, t, u, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(p) } function u(p) { return i = ft(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), p === 58 ? (t.enter("definitionMarker"), t.consume(p), t.exit("definitionMarker"), f) : n(p) } function f(p) { return j(p) ? kt(t, s)(p) : s(p) } function s(p) { return ie(t, l, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(p) } function l(p) { return t.attempt(po, d, d)(p) } function d(p) { return L(p) ? T(t, m, "whitespace")(p) : m(p) } function m(p) { return p === null || w(p) ? (t.exit("definition"), r.parser.defined.push(i), e(p)) : n(p) } } function ho(t, e, n) { return r; function r(u) { return j(u) ? kt(t, i)(u) : n(u) } function i(u) { return ae(t, o, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(u) } function o(u) { return L(u) ? T(t, a, "whitespace")(u) : a(u) } function a(u) { return u === null || w(u) ? e(u) : n(u) } } var Ve, po, wr = b(() => { Fe(); Oe(); W(); Re(); ve(); F(); Zt(); Ve = { name: "definition", tokenize: fo }, po = { tokenize: ho, partial: !0 } }); function mo(t, e, n) { return r; function r(o) { return t.enter("hardBreakEscape"), t.consume(o), i } function i(o) { return w(o) ? (t.exit("hardBreakEscape"), e(o)) : n(o) } } var _e, Sr = b(() => { F(); _e = { name: "hardBreakEscape", tokenize: mo } }); function go(t, e) { let n = t.length - 2, r = 3, i, o; return t[r][1].type === "whitespace" && (r += 2), n - 2 > r && t[n][1].type === "whitespace" && (n -= 2), t[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && t[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = { type: "atxHeadingText", start: t[r][1].start, end: t[n][1].end }, o = { type: "chunkText", start: t[r][1].start, end: t[n][1].end, contentType: "text" }, Y(t, r, n - r + 1, [["enter", i, e], ["enter", o, e], ["exit", o, e], ["exit", i, e]])), t } function xo(t, e, n) { let r = 0; return i; function i(l) { return t.enter("atxHeading"), o(l) } function o(l) { return t.enter("atxHeadingSequence"), a(l) } function a(l) { return l === 35 && r++ < 6 ? (t.consume(l), a) : l === null || j(l) ? (t.exit("atxHeadingSequence"), u(l)) : n(l) } function u(l) { return l === 35 ? (t.enter("atxHeadingSequence"), f(l)) : l === null || w(l) ? (t.exit("atxHeading"), e(l)) : L(l) ? T(t, u, "whitespace")(l) : (t.enter("atxHeadingText"), s(l)) } function f(l) { return l === 35 ? (t.consume(l), f) : (t.exit("atxHeadingSequence"), u(l)) } function s(l) { return l === null || l === 35 || j(l) ? (t.exit("atxHeadingText"), u(l)) : (t.consume(l), s) } } var He, Er = b(() => { W(); F(); mt(); He = { name: "headingAtx", tokenize: xo, resolve: go } }); var qr, Ue, Lr = b(() => { qr = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], Ue = ["pre", "script", "style", "textarea"] }); function ko(t) { let e = t.length; for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow");); return e > 1 && t[e - 2][1].type === "linePrefix" && (t[e][1].start = t[e - 2][1].start, t[e + 1][1].start = t[e - 2][1].start, t.splice(e - 2, 2)), t } function wo(t, e, n) { let r = this, i, o, a, u, f; return s; function s(h) { return l(h) } function l(h) { return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(h), d } function d(h) { return h === 33 ? (t.consume(h), m) : h === 47 ? (t.consume(h), o = !0, A) : h === 63 ? (t.consume(h), i = 3, r.interrupt ? e : c) : et(h) ? (t.consume(h), a = String.fromCharCode(h), N) : n(h) } function m(h) { return h === 45 ? (t.consume(h), i = 2, p) : h === 91 ? (t.consume(h), i = 5, u = 0, q) : et(h) ? (t.consume(h), i = 4, r.interrupt ? e : c) : n(h) } function p(h) { return h === 45 ? (t.consume(h), r.interrupt ? e : c) : n(h) } function q(h) { let $ = "CDATA["; return h === $.charCodeAt(u++) ? (t.consume(h), u === $.length ? r.interrupt ? e : O : q) : n(h) } function A(h) { return et(h) ? (t.consume(h), a = String.fromCharCode(h), N) : n(h) } function N(h) { if (h === null || h === 47 || h === 62 || j(h)) { let $ = h === 47, bt = a.toLowerCase(); return !$ && !o && Ue.includes(bt) ? (i = 1, r.interrupt ? e(h) : O(h)) : qr.includes(a.toLowerCase()) ? (i = 6, $ ? (t.consume(h), k) : r.interrupt ? e(h) : O(h)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(h) : o ? v(h) : S(h)) } return h === 45 || X(h) ? (t.consume(h), a += String.fromCharCode(h), N) : n(h) } function k(h) { return h === 62 ? (t.consume(h), r.interrupt ? e : O) : n(h) } function v(h) { return L(h) ? (t.consume(h), v) : _(h) } function S(h) { return h === 47 ? (t.consume(h), _) : h === 58 || h === 95 || et(h) ? (t.consume(h), V) : L(h) ? (t.consume(h), S) : _(h) } function V(h) { return h === 45 || h === 46 || h === 58 || h === 95 || X(h) ? (t.consume(h), V) : H(h) } function H(h) { return h === 61 ? (t.consume(h), x) : L(h) ? (t.consume(h), H) : S(h) } function x(h) { return h === null || h === 60 || h === 61 || h === 62 || h === 96 ? n(h) : h === 34 || h === 39 ? (t.consume(h), f = h, R) : L(h) ? (t.consume(h), x) : M(h) } function R(h) { return h === f ? (t.consume(h), f = null, B) : h === null || w(h) ? n(h) : (t.consume(h), R) } function M(h) { return h === null || h === 34 || h === 39 || h === 47 || h === 60 || h === 61 || h === 62 || h === 96 || j(h) ? H(h) : (t.consume(h), M) } function B(h) { return h === 47 || h === 62 || L(h) ? S(h) : n(h) } function _(h) { return h === 62 ? (t.consume(h), nt) : n(h) } function nt(h) { return h === null || w(h) ? O(h) : L(h) ? (t.consume(h), nt) : n(h) } function O(h) { return h === 45 && i === 2 ? (t.consume(h), U) : h === 60 && i === 1 ? (t.consume(h), G) : h === 62 && i === 4 ? (t.consume(h), rt) : h === 63 && i === 3 ? (t.consume(h), c) : h === 93 && i === 5 ? (t.consume(h), ut) : w(h) && (i === 6 || i === 7) ? (t.exit("htmlFlowData"), t.check(bo, lt, E)(h)) : h === null || w(h) ? (t.exit("htmlFlowData"), E(h)) : (t.consume(h), O) } function E(h) { return t.check(yo, z, lt)(h) } function z(h) { return t.enter("lineEnding"), t.consume(h), t.exit("lineEnding"), C } function C(h) { return h === null || w(h) ? E(h) : (t.enter("htmlFlowData"), O(h)) } function U(h) { return h === 45 ? (t.consume(h), c) : O(h) } function G(h) { return h === 47 ? (t.consume(h), a = "", ot) : O(h) } function ot(h) { if (h === 62) { let $ = a.toLowerCase(); return Ue.includes($) ? (t.consume(h), rt) : O(h) } return et(h) && a.length < 8 ? (t.consume(h), a += String.fromCharCode(h), ot) : O(h) } function ut(h) { return h === 93 ? (t.consume(h), c) : O(h) } function c(h) { return h === 62 ? (t.consume(h), rt) : h === 45 && i === 2 ? (t.consume(h), c) : O(h) } function rt(h) { return h === null || w(h) ? (t.exit("htmlFlowData"), lt(h)) : (t.consume(h), rt) } function lt(h) { return t.exit("htmlFlow"), e(h) } } function So(t, e, n) { let r = this; return i; function i(a) { return w(a) ? (t.enter("lineEnding"), t.consume(a), t.exit("lineEnding"), o) : n(a) } function o(a) { return r.parser.lazy[r.now().line] ? n(a) : e(a) } } function Eo(t, e, n) { return r; function r(i) { return t.enter("lineEnding"), t.consume(i), t.exit("lineEnding"), t.attempt(gt, e, n) } } var je, bo, yo, Ir = b(() => { F(); Lr(); Xt(); je = { name: "htmlFlow", tokenize: wo, resolveTo: ko, concrete: !0 }, bo = { tokenize: Eo, partial: !0 }, yo = { tokenize: So, partial: !0 } }); function qo(t, e, n) { let r = this, i, o, a; return u; function u(c) { return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(c), f } function f(c) { return c === 33 ? (t.consume(c), s) : c === 47 ? (t.consume(c), H) : c === 63 ? (t.consume(c), S) : et(c) ? (t.consume(c), M) : n(c) } function s(c) { return c === 45 ? (t.consume(c), l) : c === 91 ? (t.consume(c), o = 0, q) : et(c) ? (t.consume(c), v) : n(c) } function l(c) { return c === 45 ? (t.consume(c), p) : n(c) } function d(c) { return c === null ? n(c) : c === 45 ? (t.consume(c), m) : w(c) ? (a = d, G(c)) : (t.consume(c), d) } function m(c) { return c === 45 ? (t.consume(c), p) : d(c) } function p(c) { return c === 62 ? U(c) : c === 45 ? m(c) : d(c) } function q(c) { let rt = "CDATA["; return c === rt.charCodeAt(o++) ? (t.consume(c), o === rt.length ? A : q) : n(c) } function A(c) { return c === null ? n(c) : c === 93 ? (t.consume(c), N) : w(c) ? (a = A, G(c)) : (t.consume(c), A) } function N(c) { return c === 93 ? (t.consume(c), k) : A(c) } function k(c) { return c === 62 ? U(c) : c === 93 ? (t.consume(c), k) : A(c) } function v(c) { return c === null || c === 62 ? U(c) : w(c) ? (a = v, G(c)) : (t.consume(c), v) } function S(c) { return c === null ? n(c) : c === 63 ? (t.consume(c), V) : w(c) ? (a = S, G(c)) : (t.consume(c), S) } function V(c) { return c === 62 ? U(c) : S(c) } function H(c) { return et(c) ? (t.consume(c), x) : n(c) } function x(c) { return c === 45 || X(c) ? (t.consume(c), x) : R(c) } function R(c) { return w(c) ? (a = R, G(c)) : L(c) ? (t.consume(c), R) : U(c) } function M(c) { return c === 45 || X(c) ? (t.consume(c), M) : c === 47 || c === 62 || j(c) ? B(c) : n(c) } function B(c) { return c === 47 ? (t.consume(c), U) : c === 58 || c === 95 || et(c) ? (t.consume(c), _) : w(c) ? (a = B, G(c)) : L(c) ? (t.consume(c), B) : U(c) } function _(c) { return c === 45 || c === 46 || c === 58 || c === 95 || X(c) ? (t.consume(c), _) : nt(c) } function nt(c) { return c === 61 ? (t.consume(c), O) : w(c) ? (a = nt, G(c)) : L(c) ? (t.consume(c), nt) : B(c) } function O(c) { return c === null || c === 60 || c === 61 || c === 62 || c === 96 ? n(c) : c === 34 || c === 39 ? (t.consume(c), i = c, E) : w(c) ? (a = O, G(c)) : L(c) ? (t.consume(c), O) : (t.consume(c), z) } function E(c) { return c === i ? (t.consume(c), i = void 0, C) : c === null ? n(c) : w(c) ? (a = E, G(c)) : (t.consume(c), E) } function z(c) { return c === null || c === 34 || c === 39 || c === 60 || c === 61 || c === 96 ? n(c) : c === 47 || c === 62 || j(c) ? B(c) : (t.consume(c), z) } function C(c) { return c === 47 || c === 62 || j(c) ? B(c) : n(c) } function U(c) { return c === 62 ? (t.consume(c), t.exit("htmlTextData"), t.exit("htmlText"), e) : n(c) } function G(c) { return t.exit("htmlTextData"), t.enter("lineEnding"), t.consume(c), t.exit("lineEnding"), ot } function ot(c) { return L(c) ? T(t, ut, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(c) : ut(c) } function ut(c) { return t.enter("htmlTextData"), a(c) } } var Me, Tr = b(() => { W(); F(); Me = { name: "htmlText", tokenize: qo } }); function Ao(t) { let e = -1; for (; ++e < t.length;) { let n = t[e][1]; (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (t.splice(e + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", e++) } return t } function Co(t, e) { let n = t.length, r = 0, i, o, a, u; for (; n--;)if (i = t[n][1], o) { if (i.type === "link" || i.type === "labelLink" && i._inactive) break; t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0) } else if (a) { if (t[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = n, i.type !== "labelLink")) { r = 2; break } } else i.type === "labelEnd" && (a = n); let f = { type: t[o][1].type === "labelLink" ? "link" : "image", start: Object.assign({}, t[o][1].start), end: Object.assign({}, t[t.length - 1][1].end) }, s = { type: "label", start: Object.assign({}, t[o][1].start), end: Object.assign({}, t[a][1].end) }, l = { type: "labelText", start: Object.assign({}, t[o + r + 2][1].end), end: Object.assign({}, t[a - 2][1].start) }; return u = [["enter", f, e], ["enter", s, e]], u = K(u, t.slice(o + 1, o + r + 3)), u = K(u, [["enter", l, e]]), u = K(u, Tt(e.parser.constructs.insideSpan.null, t.slice(o + r + 4, a - 3), e)), u = K(u, [["exit", l, e], t[a - 2], t[a - 1], ["exit", s, e]]), u = K(u, t.slice(a + 1)), u = K(u, [["exit", f, e]]), Y(t, o, t.length, u), t } function zo(t, e, n) { let r = this, i = r.events.length, o, a; for (; i--;)if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) { o = r.events[i][1]; break } return u; function u(m) { return o ? o._inactive ? d(m) : (a = r.parser.defined.includes(ft(r.sliceSerialize({ start: o.end, end: r.now() }))), t.enter("labelEnd"), t.enter("labelMarker"), t.consume(m), t.exit("labelMarker"), t.exit("labelEnd"), f) : n(m) } function f(m) { return m === 40 ? t.attempt(Lo, l, a ? l : d)(m) : m === 91 ? t.attempt(Io, l, a ? s : d)(m) : a ? l(m) : d(m) } function s(m) { return t.attempt(To, l, d)(m) } function l(m) { return e(m) } function d(m) { return o._balanced = !0, n(m) } } function Do(t, e, n) { return r; function r(d) { return t.enter("resource"), t.enter("resourceMarker"), t.consume(d), t.exit("resourceMarker"), i } function i(d) { return j(d) ? kt(t, o)(d) : o(d) } function o(d) { return d === 41 ? l(d) : ie(t, a, u, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d) } function a(d) { return j(d) ? kt(t, f)(d) : l(d) } function u(d) { return n(d) } function f(d) { return d === 34 || d === 39 || d === 40 ? ae(t, s, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : l(d) } function s(d) { return j(d) ? kt(t, l)(d) : l(d) } function l(d) { return d === 41 ? (t.enter("resourceMarker"), t.consume(d), t.exit("resourceMarker"), t.exit("resource"), e) : n(d) } } function Bo(t, e, n) { let r = this; return i; function i(u) { return oe.call(r, t, o, a, "reference", "referenceMarker", "referenceString")(u) } function o(u) { return r.parser.defined.includes(ft(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(u) : n(u) } function a(u) { return n(u) } } function No(t, e, n) { return r; function r(o) { return t.enter("reference"), t.enter("referenceMarker"), t.consume(o), t.exit("referenceMarker"), i } function i(o) { return o === 93 ? (t.enter("referenceMarker"), t.consume(o), t.exit("referenceMarker"), t.exit("reference"), e) : n(o) } } var wt, Lo, Io, To, ue = b(() => { Fe(); Oe(); Re(); ve(); F(); mt(); Zt(); Kt(); wt = { name: "labelEnd", tokenize: zo, resolveTo: Co, resolveAll: Ao }, Lo = { tokenize: Do }, Io = { tokenize: Bo }, To = { tokenize: No } }); function Po(t, e, n) { let r = this; return i; function i(u) { return t.enter("labelImage"), t.enter("labelImageMarker"), t.consume(u), t.exit("labelImageMarker"), o } function o(u) { return u === 91 ? (t.enter("labelMarker"), t.consume(u), t.exit("labelMarker"), t.exit("labelImage"), a) : n(u) } function a(u) { return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(u) : e(u) } } var Ge, Ar = b(() => { ue(); Ge = { name: "labelStartImage", tokenize: Po, resolveAll: wt.resolveAll } }); function Fo(t, e, n) { let r = this; return i; function i(a) { return t.enter("labelLink"), t.enter("labelMarker"), t.consume(a), t.exit("labelMarker"), t.exit("labelLink"), o } function o(a) { return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : e(a) } } var Qe, Cr = b(() => { ue(); Qe = { name: "labelStartLink", tokenize: Fo, resolveAll: wt.resolveAll } }); function Oo(t, e) { return n; function n(r) { return t.enter("lineEnding"), t.consume(r), t.exit("lineEnding"), T(t, e, "linePrefix") } } var Vt, zr = b(() => { W(); Vt = { name: "lineEnding", tokenize: Oo } }); function Ro(t, e, n) { let r = 0, i; return o; function o(s) { return t.enter("thematicBreak"), a(s) } function a(s) { return i = s, u(s) } function u(s) { return s === i ? (t.enter("thematicBreakSequence"), f(s)) : r >= 3 && (s === null || w(s)) ? (t.exit("thematicBreak"), e(s)) : n(s) } function f(s) { return s === i ? (t.consume(s), r++, f) : (t.exit("thematicBreakSequence"), L(s) ? T(t, u, "whitespace")(s) : u(s)) } } var St, We = b(() => { W(); F(); St = { name: "thematicBreak", tokenize: Ro } }); function _o(t, e, n) { let r = this, i = r.events[r.events.length - 1], o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0; return u; function u(p) { let q = r.containerState.type || (p === 42 || p === 43 || p === 45 ? "listUnordered" : "listOrdered"); if (q === "listUnordered" ? !r.containerState.marker || p === r.containerState.marker : Ot(p)) { if (r.containerState.type || (r.containerState.type = q, t.enter(q, { _container: !0 })), q === "listUnordered") return t.enter("listItemPrefix"), p === 42 || p === 45 ? t.check(St, n, s)(p) : s(p); if (!r.interrupt || p === 49) return t.enter("listItemPrefix"), t.enter("listItemValue"), f(p) } return n(p) } function f(p) { return Ot(p) && ++a < 10 ? (t.consume(p), f) : (!r.interrupt || a < 2) && (r.containerState.marker ? p === r.containerState.marker : p === 41 || p === 46) ? (t.exit("listItemValue"), s(p)) : n(p) } function s(p) { return t.enter("listItemMarker"), t.consume(p), t.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || p, t.check(gt, r.interrupt ? n : l, t.attempt(vo, m, d)) } function l(p) { return r.containerState.initialBlankLine = !0, o++, m(p) } function d(p) { return L(p) ? (t.enter("listItemPrefixWhitespace"), t.consume(p), t.exit("listItemPrefixWhitespace"), m) : n(p) } function m(p) { return r.containerState.size = o + r.sliceSerialize(t.exit("listItemPrefix"), !0).length, e(p) } } function Ho(t, e, n) { let r = this; return r.containerState._closeFlow = void 0, t.check(gt, i, o); function i(u) { return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, T(t, e, "listItemIndent", r.containerState.size + 1)(u) } function o(u) { return r.containerState.furtherBlankLines || !L(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, t.attempt(Vo, e, a)(u)) } function a(u) { return r.containerState._closeFlow = !0, r.interrupt = void 0, T(t, t.attempt(Z, e, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(u) } } function Uo(t, e, n) { let r = this; return T(t, i, "listItemIndent", r.containerState.size + 1); function i(o) { let a = r.events[r.events.length - 1]; return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? e(o) : n(o) } } function jo(t) { t.exit(this.containerState.type) } function Mo(t, e, n) { let r = this; return T(t, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5); function i(o) { let a = r.events[r.events.length - 1]; return !L(o) && a && a[1].type === "listItemPrefixWhitespace" ? e(o) : n(o) } } var Z, vo, Vo, Dr = b(() => { W(); F(); Xt(); We(); Z = { name: "list", tokenize: _o, continuation: { tokenize: Ho }, exit: jo }, vo = { tokenize: Mo, partial: !0 }, Vo = { tokenize: Uo, partial: !0 } }); function Go(t, e) { let n = t.length, r, i, o; for (; n--;)if (t[n][0] === "enter") { if (t[n][1].type === "content") { r = n; break } t[n][1].type === "paragraph" && (i = n) } else t[n][1].type === "content" && t.splice(n, 1), !o && t[n][1].type === "definition" && (o = n); let a = { type: "setextHeading", start: Object.assign({}, t[i][1].start), end: Object.assign({}, t[t.length - 1][1].end) }; return t[i][1].type = "setextHeadingText", o ? (t.splice(i, 0, ["enter", a, e]), t.splice(o + 1, 0, ["exit", t[r][1], e]), t[r][1].end = Object.assign({}, t[o][1].end)) : t[r][1] = a, t.push(["exit", a, e]), t } function Qo(t, e, n) { let r = this, i; return o; function o(s) { let l = r.events.length, d; for (; l--;)if (r.events[l][1].type !== "lineEnding" && r.events[l][1].type !== "linePrefix" && r.events[l][1].type !== "content") { d = r.events[l][1].type === "paragraph"; break } return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (t.enter("setextHeadingLine"), i = s, a(s)) : n(s) } function a(s) { return t.enter("setextHeadingLineSequence"), u(s) } function u(s) { return s === i ? (t.consume(s), u) : (t.exit("setextHeadingLineSequence"), L(s) ? T(t, f, "lineSuffix")(s) : f(s)) } function f(s) { return s === null || w(s) ? (t.exit("setextHeadingLine"), e(s)) : n(s) } } var se, Br = b(() => { W(); F(); se = { name: "setextUnderline", tokenize: Qo, resolveTo: Go } }); var Je = b(() => { pr(); fr(); Xt(); hr(); mr(); dr(); xr(); br(); yr(); kr(); wr(); Sr(); Er(); Ir(); Tr(); ue(); Ar(); Cr(); zr(); Dr(); Br(); We() }); function Wo(t) { let e = this, n = t.attempt(gt, r, t.attempt(this.parser.constructs.flowInitial, i, T(t, t.attempt(this.parser.constructs.flow, i, t.attempt(Pe, i)), "linePrefix"))); return n; function r(o) { if (o === null) { t.consume(o); return } return t.enter("lineEndingBlank"), t.consume(o), t.exit("lineEndingBlank"), e.currentConstruct = void 0, n } function i(o) { if (o === null) { t.consume(o); return } return t.enter("lineEnding"), t.consume(o), t.exit("lineEnding"), e.currentConstruct = void 0, n } } var Nr, Pr = b(() => { Je(); W(); Nr = { tokenize: Wo } }); function vr(t) { return { tokenize: e, resolveAll: Vr(t === "text" ? Jo : void 0) }; function e(n) { let r = this, i = this.parser.constructs[t], o = n.attempt(i, a, u); return a; function a(l) { return s(l) ? o(l) : u(l) } function u(l) { if (l === null) { n.consume(l); return } return n.enter("data"), n.consume(l), f } function f(l) { return s(l) ? (n.exit("data"), o(l)) : (n.consume(l), f) } function s(l) { if (l === null) return !0; let d = i[l], m = -1; if (d) for (; ++m < d.length;) { let p = d[m]; if (!p.previous || p.previous.call(r, r.previous)) return !0 } return !1 } } } function Vr(t) { return e; function e(n, r) { let i = -1, o; for (; ++i <= n.length;)o === void 0 ? n[i] && n[i][1].type === "data" && (o = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== o + 2 && (n[o][1].end = n[i - 1][1].end, n.splice(o + 2, i - o - 2), i = o + 2), o = void 0); return t ? t(n, r) : n } } function Jo(t, e) { let n = 0; for (; ++n <= t.length;)if ((n === t.length || t[n][1].type === "lineEnding") && t[n - 1][1].type === "data") { let r = t[n - 1][1], i = e.sliceStream(r), o = i.length, a = -1, u = 0, f; for (; o--;) { let s = i[o]; if (typeof s == "string") { for (a = s.length; s.charCodeAt(a - 1) === 32;)u++, a--; if (a) break; a = -1 } else if (s === -2) f = !0, u++; else if (s !== -1) { o++; break } } if (u) { let s = { type: n === t.length || f || u < 2 ? "lineSuffix" : "hardBreakTrailing", start: { line: r.end.line, column: r.end.column - u, offset: r.end.offset - u, _index: r.start._index + o, _bufferIndex: o ? a : r.start._bufferIndex + a }, end: Object.assign({}, r.end) }; r.end = Object.assign({}, s.start), r.start.offset === r.end.offset ? Object.assign(r, s) : (t.splice(n, 0, ["enter", s, e], ["exit", s, e]), n += 2) } n++ } return t } var Fr, Or, Rr, Ye = b(() => { Fr = { resolveAll: Vr() }, Or = vr("string"), Rr = vr("text") }); function _r(t, e, n) { let r = Object.assign(n ? Object.assign({}, n) : { line: 1, column: 1, offset: 0 }, { _index: 0, _bufferIndex: -1 }), i = {}, o = [], a = [], u = [], f = !0, s = { consume: V, enter: H, exit: x, attempt: B(R), check: B(M), interrupt: B(M, { interrupt: !0 }) }, l = { previous: null, code: null, containerState: {}, events: [], parser: t, sliceStream: A, sliceSerialize: q, now: N, defineSkip: k, write: p }, d = e.tokenize.call(l, s), m; return e.resolveAll && o.push(e), l; function p(E) { return a = K(a, E), v(), a[a.length - 1] !== null ? [] : (_(e, 0), l.events = Tt(o, l.events, l), l.events) } function q(E, z) { return Zo(A(E), z) } function A(E) { return Yo(a, E) } function N() { let { line: E, column: z, offset: C, _index: U, _bufferIndex: G } = r; return { line: E, column: z, offset: C, _index: U, _bufferIndex: G } } function k(E) { i[E.line] = E.column, O() } function v() { let E; for (; r._index < a.length;) { let z = a[r._index]; if (typeof z == "string") for (E = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === E && r._bufferIndex < z.length;)S(z.charCodeAt(r._bufferIndex)); else S(z) } } function S(E) { f = void 0, m = E, d = d(E) } function V(E) { w(E) ? (r.line++, r.column = 1, r.offset += E === -3 ? 2 : 1, O()) : E !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === a[r._index].length && (r._bufferIndex = -1, r._index++)), l.previous = E, f = !0 } function H(E, z) { let C = z || {}; return C.type = E, C.start = N(), l.events.push(["enter", C, l]), u.push(C), C } function x(E) { let z = u.pop(); return z.end = N(), l.events.push(["exit", z, l]), z } function R(E, z) { _(E, z.from) } function M(E, z) { z.restore() } function B(E, z) { return C; function C(U, G, ot) { let ut, c, rt, lt; return Array.isArray(U) ? $(U) : "tokenize" in U ? $([U]) : h(U); function h(J) { return Ct; function Ct(st) { let Et = st !== null && J[st], qt = st !== null && J.null, fe = [...Array.isArray(Et) ? Et : Et ? [Et] : [], ...Array.isArray(qt) ? qt : qt ? [qt] : []]; return $(fe)(st) } } function $(J) { return ut = J, c = 0, J.length === 0 ? ot : bt(J[c]) } function bt(J) { return Ct; function Ct(st) { return lt = nt(), rt = J, J.partial || (l.currentConstruct = J), J.name && l.parser.constructs.disable.null.includes(J.name) ? Ut(st) : J.tokenize.call(z ? Object.assign(Object.create(l), z) : l, s, pe, Ut)(st) } } function pe(J) { return f = !0, E(rt, lt), G } function Ut(J) { return f = !0, lt.restore(), ++c < ut.length ? bt(ut[c]) : ot } } } function _(E, z) { E.resolveAll && !o.includes(E) && o.push(E), E.resolve && Y(l.events, z, l.events.length - z, E.resolve(l.events.slice(z), l)), E.resolveTo && (l.events = E.resolveTo(l.events, l)) } function nt() { let E = N(), z = l.previous, C = l.currentConstruct, U = l.events.length, G = Array.from(u); return { restore: ot, from: U }; function ot() { r = E, l.previous = z, l.currentConstruct = C, l.events.length = U, u = G, O() } } function O() { r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1) } } function Yo(t, e) { let n = e.start._index, r = e.start._bufferIndex, i = e.end._index, o = e.end._bufferIndex, a; if (n === i) a = [t[n].slice(r, o)]; else { if (a = t.slice(n, i), r > -1) { let u = a[0]; typeof u == "string" ? a[0] = u.slice(r) : a.shift() } o > 0 && a.push(t[i].slice(0, o)) } return a } function Zo(t, e) {
	let n = -1, r = [], i; for (; ++n < t.length;) {
		let o = t[n], a; if (typeof o == "string") a = o; else switch (o) {
			case -5: { a = "\r"; break } case -4: {
				a = `
`; break
			} case -3: {
				a = `\r
`; break
			} case -2: { a = e ? " " : "	"; break } case -1: { if (!e && i) continue; a = " "; break } default: a = String.fromCharCode(o)
		}i = o === -2, r.push(a)
	} return r.join("")
} var Hr = b(() => { F(); mt(); Kt() }); var Ze = {}; Bt(Ze, { attentionMarkers: () => ia, contentInitial: () => Xo, disable: () => oa, document: () => Ko, flow: () => ta, flowInitial: () => $o, insideSpan: () => ra, string: () => ea, text: () => na }); var Ko, Xo, $o, ta, ea, na, ra, ia, oa, Ur = b(() => { Je(); Ye(); Ko = { 42: Z, 43: Z, 45: Z, 48: Z, 49: Z, 50: Z, 51: Z, 52: Z, 53: Z, 54: Z, 55: Z, 56: Z, 57: Z, 62: $t }, Xo = { 91: Ve }, $o = { [-2]: vt, [-1]: vt, 32: vt }, ta = { 35: He, 42: St, 45: [se, St], 60: je, 61: se, 95: St, 96: ne, 126: ne }, ea = { 38: ee, 92: te }, na = { [-5]: Vt, [-4]: Vt, [-3]: Vt, 33: Ge, 38: ee, 42: Rt, 60: [De, Me], 91: Qe, 92: [_e, te], 93: wt, 95: Rt, 96: Be }, ra = { null: [Rt, Fr] }, ia = { null: [42, 95] }, oa = { null: [] } }); function Ke(t) { let n = Xn([Ze, ...(t || {}).extensions || []]), r = { defined: [], lazy: {}, constructs: n, content: i(ir), document: i(ur), flow: i(Nr), string: i(Or), text: i(Rr) }; return r; function i(o) { return a; function a(u) { return _r(r, o, u) } } } var jr = b(() => { $n(); or(); sr(); Pr(); Ye(); Hr(); Ur() }); function Xe(t) { for (; !re(t);); return t } var Mr = b(() => { Ne() }); function $e() { let t = 1, e = "", n = !0, r; return i; function i(o, a, u) { let f = [], s, l, d, m, p; for (o = e + (typeof o == "string" ? o.toString() : new TextDecoder(a || void 0).decode(o)), d = 0, e = "", n && (o.charCodeAt(0) === 65279 && d++, n = void 0); d < o.length;) { if (Gr.lastIndex = d, s = Gr.exec(o), m = s && s.index !== void 0 ? s.index : o.length, p = o.charCodeAt(m), !s) { e = o.slice(d); break } if (p === 10 && d === m && r) f.push(-3), r = void 0; else switch (r && (f.push(-5), r = void 0), d < m && (f.push(o.slice(d, m)), t += m - d), p) { case 0: { f.push(65533), t++; break } case 9: { for (l = Math.ceil(t / 4) * 4, f.push(-2); t++ < l;)f.push(-1); break } case 10: { f.push(-4), t = 1; break } default: r = !0, t = 1 }d = m + 1 } return u && (r && f.push(-5), e && f.push(e), f.push(null)), f } } var Gr, Qr = b(() => { Gr = /[\0\t\n\r]/g }); var Wr = b(() => { jr(); Mr(); Qr() }); function Jr(t) { return t.replace(aa, ua) } function ua(t, e, n) { if (e) return e; if (n.charCodeAt(0) === 35) { let i = n.charCodeAt(1), o = i === 120 || i === 88; return Yt(n.slice(o ? 2 : 1), o ? 16 : 10) } return It(n) || t } var aa, Yr = b(() => { Jt(); Ae(); aa = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi }); function tn(t, e, n) { return typeof e != "string" && (n = e, e = void 0), sa(n)(Xe(Ke(n).document().write($e()(t, e, !0)))) } function sa(t) { let e = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: o(cn), autolinkProtocol: B, autolinkEmail: B, atxHeading: o(un), blockQuote: o(Ct), characterEscape: B, characterReference: B, codeFenced: o(st), codeFencedFenceInfo: a, codeFencedFenceMeta: a, codeIndented: o(st, a), codeText: o(Et, a), codeTextData: B, data: B, codeFlowValue: B, definition: o(qt), definitionDestinationString: a, definitionLabelString: a, definitionTitleString: a, emphasis: o(fe), hardBreakEscape: o(sn), hardBreakTrailing: o(sn), htmlFlow: o(ln, a), htmlFlowData: B, htmlText: o(ln, a), htmlTextData: B, image: o(di), label: a, link: o(cn), listItem: o(gi), listItemValue: m, listOrdered: o(pn, d), listUnordered: o(pn), paragraph: o(xi), reference: h, referenceString: a, resourceDestinationString: a, resourceTitleString: a, setextHeading: o(un), strong: o(bi), thematicBreak: o(ki) }, exit: { atxHeading: f(), atxHeadingSequence: H, autolink: f(), autolinkEmail: J, autolinkProtocol: Ut, blockQuote: f(), characterEscapeValue: _, characterReferenceMarkerHexadecimal: bt, characterReferenceMarkerNumeric: bt, characterReferenceValue: pe, codeFenced: f(N), codeFencedFence: A, codeFencedFenceInfo: p, codeFencedFenceMeta: q, codeFlowValue: _, codeIndented: f(k), codeText: f(C), codeTextData: _, data: _, definition: f(), definitionDestinationString: V, definitionLabelString: v, definitionTitleString: S, emphasis: f(), hardBreakEscape: f(O), hardBreakTrailing: f(O), htmlFlow: f(E), htmlFlowData: _, htmlText: f(z), htmlTextData: _, image: f(G), label: ut, labelText: ot, lineEnding: nt, link: f(U), listItem: f(), listOrdered: f(), listUnordered: f(), paragraph: f(), referenceString: $, resourceDestinationString: c, resourceTitleString: rt, resource: lt, setextHeading: f(M), setextHeadingLineSequence: R, setextHeadingText: x, strong: f(), thematicBreak: f() } }; Xr(e, (t || {}).mdastExtensions || []); let n = {}; return r; function r(g) { let y = { type: "root", children: [] }, I = { stack: [y], tokenStack: [], config: e, enter: u, exit: s, buffer: a, resume: l, data: n }, D = [], P = -1; for (; ++P < g.length;)if (g[P][1].type === "listOrdered" || g[P][1].type === "listUnordered") if (g[P][0] === "enter") D.push(P); else { let at = D.pop(); P = i(g, at, P) } for (P = -1; ++P < g.length;) { let at = e[g[P][0]]; Kr.call(at, g[P][1].type) && at[g[P][1].type].call(Object.assign({ sliceSerialize: g[P][2].sliceSerialize }, I), g[P][1]) } if (I.tokenStack.length > 0) { let at = I.tokenStack[I.tokenStack.length - 1]; (at[1] || Zr).call(I, void 0, at[0]) } for (y.position = { start: xt(g.length > 0 ? g[0][1].start : { line: 1, column: 1, offset: 0 }), end: xt(g.length > 0 ? g[g.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, P = -1; ++P < e.transforms.length;)y = e.transforms[P](y) || y; return y } function i(g, y, I) { let D = y - 1, P = -1, at = !1, yt, ct, zt, Dt; for (; ++D <= I;) { let tt = g[D]; switch (tt[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": { tt[0] === "enter" ? P++ : P--, Dt = void 0; break } case "lineEndingBlank": { tt[0] === "enter" && (yt && !Dt && !P && !zt && (zt = D), Dt = void 0); break } case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: Dt = void 0 }if (!P && tt[0] === "enter" && tt[1].type === "listItemPrefix" || P === -1 && tt[0] === "exit" && (tt[1].type === "listUnordered" || tt[1].type === "listOrdered")) { if (yt) { let Lt = D; for (ct = void 0; Lt--;) { let pt = g[Lt]; if (pt[1].type === "lineEnding" || pt[1].type === "lineEndingBlank") { if (pt[0] === "exit") continue; ct && (g[ct][1].type = "lineEndingBlank", at = !0), pt[1].type = "lineEnding", ct = Lt } else if (!(pt[1].type === "linePrefix" || pt[1].type === "blockQuotePrefix" || pt[1].type === "blockQuotePrefixWhitespace" || pt[1].type === "blockQuoteMarker" || pt[1].type === "listItemIndent")) break } zt && (!ct || zt < ct) && (yt._spread = !0), yt.end = Object.assign({}, ct ? g[ct][1].start : tt[1].end), g.splice(ct || D, 0, ["exit", yt, tt[2]]), D++, I++ } if (tt[1].type === "listItemPrefix") { let Lt = { type: "listItem", _spread: !1, start: Object.assign({}, tt[1].start), end: void 0 }; yt = Lt, g.splice(D, 0, ["enter", Lt, tt[2]]), D++, I++, zt = void 0, Dt = !0 } } } return g[y][1]._spread = at, I } function o(g, y) { return I; function I(D) { u.call(this, g(D), D), y && y.call(this, D) } } function a() { this.stack.push({ type: "fragment", children: [] }) } function u(g, y, I) { this.stack[this.stack.length - 1].children.push(g), this.stack.push(g), this.tokenStack.push([y, I]), g.position = { start: xt(y.start), end: void 0 } } function f(g) { return y; function y(I) { g && g.call(this, I), s.call(this, I) } } function s(g, y) { let I = this.stack.pop(), D = this.tokenStack.pop(); if (D) D[0].type !== g.type && (y ? y.call(this, g, D[0]) : (D[1] || Zr).call(this, g, D[0])); else throw new Error("Cannot close `" + g.type + "` (" + ht({ start: g.start, end: g.end }) + "): it\u2019s not open"); I.position.end = xt(g.end) } function l() { return Ie(this.stack.pop()) } function d() { this.data.expectingFirstListItemValue = !0 } function m(g) { if (this.data.expectingFirstListItemValue) { let y = this.stack[this.stack.length - 2]; y.start = Number.parseInt(this.sliceSerialize(g), 10), this.data.expectingFirstListItemValue = void 0 } } function p() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.lang = g } function q() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.meta = g } function A() { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) } function N() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.value = g.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 } function k() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.value = g.replace(/(\r?\n|\r)$/g, "") } function v(g) { let y = this.resume(), I = this.stack[this.stack.length - 1]; I.label = y, I.identifier = ft(this.sliceSerialize(g)).toLowerCase() } function S() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.title = g } function V() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.url = g } function H(g) { let y = this.stack[this.stack.length - 1]; if (!y.depth) { let I = this.sliceSerialize(g).length; y.depth = I } } function x() { this.data.setextHeadingSlurpLineEnding = !0 } function R(g) { let y = this.stack[this.stack.length - 1]; y.depth = this.sliceSerialize(g).codePointAt(0) === 61 ? 1 : 2 } function M() { this.data.setextHeadingSlurpLineEnding = void 0 } function B(g) { let I = this.stack[this.stack.length - 1].children, D = I[I.length - 1]; (!D || D.type !== "text") && (D = yi(), D.position = { start: xt(g.start), end: void 0 }, I.push(D)), this.stack.push(D) } function _(g) { let y = this.stack.pop(); y.value += this.sliceSerialize(g), y.position.end = xt(g.end) } function nt(g) { let y = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) { let I = y.children[y.children.length - 1]; I.position.end = xt(g.end), this.data.atHardBreak = void 0; return } !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(y.type) && (B.call(this, g), _.call(this, g)) } function O() { this.data.atHardBreak = !0 } function E() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.value = g } function z() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.value = g } function C() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.value = g } function U() { let g = this.stack[this.stack.length - 1]; if (this.data.inReference) { let y = this.data.referenceType || "shortcut"; g.type += "Reference", g.referenceType = y, delete g.url, delete g.title } else delete g.identifier, delete g.label; this.data.referenceType = void 0 } function G() { let g = this.stack[this.stack.length - 1]; if (this.data.inReference) { let y = this.data.referenceType || "shortcut"; g.type += "Reference", g.referenceType = y, delete g.url, delete g.title } else delete g.identifier, delete g.label; this.data.referenceType = void 0 } function ot(g) { let y = this.sliceSerialize(g), I = this.stack[this.stack.length - 2]; I.label = Jr(y), I.identifier = ft(y).toLowerCase() } function ut() { let g = this.stack[this.stack.length - 1], y = this.resume(), I = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, I.type === "link") { let D = g.children; I.children = D } else I.alt = y } function c() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.url = g } function rt() { let g = this.resume(), y = this.stack[this.stack.length - 1]; y.title = g } function lt() { this.data.inReference = void 0 } function h() { this.data.referenceType = "collapsed" } function $(g) { let y = this.resume(), I = this.stack[this.stack.length - 1]; I.label = y, I.identifier = ft(this.sliceSerialize(g)).toLowerCase(), this.data.referenceType = "full" } function bt(g) { this.data.characterReferenceType = g.type } function pe(g) { let y = this.sliceSerialize(g), I = this.data.characterReferenceType, D; I ? (D = Yt(y, I === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : D = It(y); let P = this.stack.pop(); P.value += D, P.position.end = xt(g.end) } function Ut(g) { _.call(this, g); let y = this.stack[this.stack.length - 1]; y.url = this.sliceSerialize(g) } function J(g) { _.call(this, g); let y = this.stack[this.stack.length - 1]; y.url = "mailto:" + this.sliceSerialize(g) } function Ct() { return { type: "blockquote", children: [] } } function st() { return { type: "code", lang: null, meta: null, value: "" } } function Et() { return { type: "inlineCode", value: "" } } function qt() { return { type: "definition", identifier: "", label: null, title: null, url: "" } } function fe() { return { type: "emphasis", children: [] } } function un() { return { type: "heading", depth: 0, children: [] } } function sn() { return { type: "break" } } function ln() { return { type: "html", value: "" } } function di() { return { type: "image", title: null, url: "", alt: null } } function cn() { return { type: "link", title: null, url: "", children: [] } } function pn(g) { return { type: "list", ordered: g.type === "listOrdered", start: null, spread: g._spread, children: [] } } function gi(g) { return { type: "listItem", spread: g._spread, checked: null, children: [] } } function xi() { return { type: "paragraph", children: [] } } function bi() { return { type: "strong", children: [] } } function yi() { return { type: "text", value: "" } } function ki() { return { type: "thematicBreak" } } } function xt(t) { return { line: t.line, column: t.column, offset: t.offset } } function Xr(t, e) { let n = -1; for (; ++n < e.length;) { let r = e[n]; Array.isArray(r) ? Xr(t, r) : la(t, r) } } function la(t, e) { let n; for (n in e) if (Kr.call(e, n)) switch (n) { case "canContainEols": { let r = e[n]; r && t[n].push(...r); break } case "transforms": { let r = e[n]; r && t[n].push(...r); break } case "enter": case "exit": { let r = e[n]; r && Object.assign(t[n], r); break } } } function Zr(t, e) { throw t ? new Error("Cannot close `" + t.type + "` (" + ht({ start: t.start, end: t.end }) + "): a different token (`" + e.type + "`, " + ht({ start: e.start, end: e.end }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + ht({ start: e.start, end: e.end }) + ") is still open") } var Kr, $r = b(() => { Yn(); Wr(); Ae(); Yr(); Zt(); Jt(); ge(); Kr = {}.hasOwnProperty }); var ti = b(() => { $r() }); function en(t) { let e = this; e.parser = n; function n(r) { return tn(r, { ...e.data("settings"), ...t, extensions: e.data("micromarkExtensions") || [], mdastExtensions: e.data("fromMarkdownExtensions") || [] }) } } var ei = b(() => { ti() }); var ni = {}; Bt(ni, { default: () => en }); var ri = b(() => { ei() }); function ca(t) { let e = [], n = -1; for (; ++n < t.length;)e[n] = le(t[n]); return ce(r); function r(...i) { let o = -1; for (; ++o < e.length;)if (e[o].apply(this, i)) return !0; return !1 } } function pa(t) { let e = t; return ce(n); function n(r) { let i = r, o; for (o in t) if (i[o] !== e[o]) return !1; return !0 } } function fa(t) { return ce(e); function e(n) { return n && n.type === t } } function ce(t) { return e; function e(n, r, i) { return !!(ma(n) && t.call(this, n, typeof r == "number" ? r : void 0, i || void 0)) } } function ha() { return !0 } function ma(t) { return t !== null && typeof t == "object" && "type" in t } var le, ii = b(() => { le = function (t) { if (t == null) return ha; if (typeof t == "function") return ce(t); if (typeof t == "object") return Array.isArray(t) ? ca(t) : pa(t); if (typeof t == "string") return fa(t); throw new Error("Expected function, string, or object as test") } }); var oi = b(() => { ii() }); function ai(t) { return "\x1B[33m" + t + "\x1B[39m" } var ui = b(() => { }); function nn(t, e, n, r) { let i; typeof e == "function" && typeof n != "function" ? (r = n, n = e) : i = e; let o = le(i), a = r ? -1 : 1; u(t, void 0, [])(); function u(f, s, l) { let d = f && typeof f == "object" ? f : {}; if (typeof d.type == "string") { let p = typeof d.tagName == "string" ? d.tagName : typeof d.name == "string" ? d.name : void 0; Object.defineProperty(m, "name", { value: "node (" + ai(f.type + (p ? "<" + p + ">" : "")) + ")" }) } return m; function m() { let p = si, q, A, N; if ((!e || o(f, s, l[l.length - 1] || void 0)) && (p = da(n(f, l)), p[0] === At)) return p; if ("children" in f && f.children) { let k = f; if (k.children && p[0] !== Ht) for (A = (r ? k.children.length : -1) + a, N = l.concat(k); A > -1 && A < k.children.length;) { let v = k.children[A]; if (q = u(v, A, N)(), q[0] === At) return q; A = typeof q[1] == "number" ? q[1] : A + a } } return p } } } function da(t) { return Array.isArray(t) ? t : typeof t == "number" ? [_t, t] : t == null ? si : [t] } var si, _t, At, Ht, li = b(() => { oi(); ui(); si = [], _t = !0, At = !1, Ht = "skip" }); var rn = b(() => { li() }); function ci(t, e, n, r) { let i, o, a; typeof e == "function" && typeof n != "function" ? (o = void 0, a = e, i = n) : (o = e, a = n, i = r), nn(t, o, u, i); function u(f, s) { let l = s[s.length - 1], d = l ? l.children.indexOf(f) : void 0; return a(f, d, l) } } var pi = b(() => { rn(); rn() }); var fi = {}; Bt(fi, { CONTINUE: () => _t, EXIT: () => At, SKIP: () => Ht, visit: () => ci }); var hi = b(() => { pi() }); var ga = {}; Bt(ga, { MdListConverter: () => an }); module.exports = Ti(ga); var on = require("os"), mi = /\r?\n|\r/g, an = class t { constructor(e, n) { this.markdown = e; this.tree = n } static async createConverter(e) { return new t(...await this.initConverter(e)) } static async initConverter(e) { return [e, await this.parseMd(e)] } async lists2heading(e) { e = Object.assign({ intent: "  " }, e); let n = this.findLists(), r = []; for (let o of n) { let a = await this.list2heading(o, e); r.push(a) } return this.replaceList(n, r) } static async parseMd(e) { let n = (await Promise.resolve().then(() => (Gn(), Mn))).unified, r = (await Promise.resolve().then(() => (ri(), ni))).default; return n().use(r).parse(e) } findLists() { return this.tree.children.filter(n => n.type === "list") } async list2heading(e, n) { let r = this.findHeadingLevel(e), i = { type: "root", children: [] }; return await this.visitList(e, r, (o, a) => { let u = { type: "heading", depth: a, children: [this.getListItemTitle(o)] }; i.children.push(u); let f = this.getListItemContent(o); if (f.length > 0) { let s = { type: "paragraph", children: f }; i.children.push(s) } }, o => { i.children.push(o) }), this.listAndHeadingMdastStringify(i, n) } getListItemContent(e) { let n = [], r = e.children.find(o => o.type === "paragraph").children.find(o => o.type === "text"); if (r) { let a = r.value.split(mi).slice(1); if (a.length > 0) { let u = JSON.parse(JSON.stringify(r)); u.value = a.join(on.EOL), n.push(u) } } let i = e.children.find(o => o.type === "paragraph").children.slice(1); return n.push(...i), n } getListItemTitle(e) { let n = e.children.find(i => i.type === "paragraph").children[0], r = JSON.parse(JSON.stringify(n)); return r.type === "text" && (r.value = r.value.split(mi)[0]), r } findHeadingLevel(e) { let n = 0; for (let r of this.tree.children) if (r.type === "heading") n = r.depth; else if (r === e) break; return n } async visitList(e, n, r, i) { let o = (await Promise.resolve().then(() => (hi(), fi))).visit; function a(u, f) { let s = f + n; if (s <= 6) for (let l of u.children) { r(l, s); for (let d of l.children) d.type === "list" && a(d, f + 1) } else i(u) } a(e, 1) } replaceList(e, n) { function r(a, u) { u.sort((s, l) => s.start - l.start); let f = ""; for (let s = 0; s < u.length; s++) { let l, d = s === 0, m = s === u.length - 1; d || m ? (d && (f += a.slice(0, u[s].start), m || (l = a.slice(u[s].end + 1, u[s + 1].start))), m && (l = a.slice(u[s].end + 1))) : l = a.slice(u[s].end + 1, u[s + 1].start), f += u[s].data, f += l } return f } let i = this.markdown; return r(i, e.map((a, u) => ({ start: a.position.start.offset, end: a.position.end.offset, data: n[u] }))) } listAndHeadingMdastStringify(e, n) { let r = ""; function i(a) { let u = []; function f(s) { u.push(s); function l() { for (let d of s.children) f(d) } if (s.type === "listItem") { let d = 0; for (let m of u) m.type === "listItem" && d++; r += n.intent.repeat(d - 1) + "- ", l() } else if (s.type === "heading") r += "#".repeat(s.depth) + " ", l(); else if ("value" in s) { if (r += s.value, u.length >= 2) { let m = u[u.length - 2].children, p = m.indexOf(s), q = m[p + 1]; (q?.type === "listItem" || q?.type === "heading" || q?.type === "list" || q?.type === void 0) && (r += on.EOL) } } else if ("children" in s) for (let d of s.children) f(d); else throw new Error(`Unknown node type: ${s.type}`); u.pop() } return f } return i(e)(e), r } }; 0 && (module.exports = { MdListConverter });
